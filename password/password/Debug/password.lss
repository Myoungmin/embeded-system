
password.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000e6e  00000ee2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e6e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000eee  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f20  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000020  00000000  00000000  00000f60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001cd2  00000000  00000000  00000f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000828  00000000  00000000  00002c52  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001016  00000000  00000000  0000347a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000034  00000000  00000000  00004490  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000044f  00000000  00000000  000044c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002675  00000000  00000000  00004913  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000010  00000000  00000000  00006f88  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	58 c0       	rjmp	.+176    	; 0xb6 <__bad_interrupt>
   6:	00 00       	nop
   8:	56 c0       	rjmp	.+172    	; 0xb6 <__bad_interrupt>
   a:	00 00       	nop
   c:	54 c0       	rjmp	.+168    	; 0xb6 <__bad_interrupt>
   e:	00 00       	nop
  10:	52 c0       	rjmp	.+164    	; 0xb6 <__bad_interrupt>
  12:	00 00       	nop
  14:	50 c0       	rjmp	.+160    	; 0xb6 <__bad_interrupt>
  16:	00 00       	nop
  18:	4e c0       	rjmp	.+156    	; 0xb6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	4c c0       	rjmp	.+152    	; 0xb6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	4a c0       	rjmp	.+148    	; 0xb6 <__bad_interrupt>
  22:	00 00       	nop
  24:	48 c0       	rjmp	.+144    	; 0xb6 <__bad_interrupt>
  26:	00 00       	nop
  28:	46 c0       	rjmp	.+140    	; 0xb6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	44 c0       	rjmp	.+136    	; 0xb6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	42 c0       	rjmp	.+132    	; 0xb6 <__bad_interrupt>
  32:	00 00       	nop
  34:	40 c0       	rjmp	.+128    	; 0xb6 <__bad_interrupt>
  36:	00 00       	nop
  38:	3e c0       	rjmp	.+124    	; 0xb6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	3c c0       	rjmp	.+120    	; 0xb6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	3a c0       	rjmp	.+116    	; 0xb6 <__bad_interrupt>
  42:	00 00       	nop
  44:	38 c0       	rjmp	.+112    	; 0xb6 <__bad_interrupt>
  46:	00 00       	nop
  48:	36 c0       	rjmp	.+108    	; 0xb6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	34 c0       	rjmp	.+104    	; 0xb6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	32 c0       	rjmp	.+100    	; 0xb6 <__bad_interrupt>
  52:	00 00       	nop
  54:	30 c0       	rjmp	.+96     	; 0xb6 <__bad_interrupt>
  56:	00 00       	nop
  58:	2e c0       	rjmp	.+92     	; 0xb6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	2c c0       	rjmp	.+88     	; 0xb6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	2a c0       	rjmp	.+84     	; 0xb6 <__bad_interrupt>
  62:	00 00       	nop
  64:	28 c0       	rjmp	.+80     	; 0xb6 <__bad_interrupt>
  66:	00 00       	nop
  68:	26 c0       	rjmp	.+76     	; 0xb6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	24 c0       	rjmp	.+72     	; 0xb6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	22 c0       	rjmp	.+68     	; 0xb6 <__bad_interrupt>
  72:	00 00       	nop
  74:	20 c0       	rjmp	.+64     	; 0xb6 <__bad_interrupt>
  76:	00 00       	nop
  78:	1e c0       	rjmp	.+60     	; 0xb6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	1c c0       	rjmp	.+56     	; 0xb6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	1a c0       	rjmp	.+52     	; 0xb6 <__bad_interrupt>
  82:	00 00       	nop
  84:	18 c0       	rjmp	.+48     	; 0xb6 <__bad_interrupt>
  86:	00 00       	nop
  88:	16 c0       	rjmp	.+44     	; 0xb6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ee e6       	ldi	r30, 0x6E	; 110
  a0:	fe e0       	ldi	r31, 0x0E	; 14
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ac 30       	cpi	r26, 0x0C	; 12
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
  b2:	02 d0       	rcall	.+4      	; 0xb8 <main>
  b4:	da c6       	rjmp	.+3508   	; 0xe6a <_exit>

000000b6 <__bad_interrupt>:
  b6:	a4 cf       	rjmp	.-184    	; 0x0 <__vectors>

000000b8 <main>:
#include <avr/io.h>
#include <util/delay.h>


int main(void)
{
  b8:	cf 93       	push	r28
  ba:	df 93       	push	r29
  bc:	cd b7       	in	r28, 0x3d	; 61
  be:	de b7       	in	r29, 0x3e	; 62
  c0:	61 97       	sbiw	r28, 0x11	; 17
  c2:	0f b6       	in	r0, 0x3f	; 63
  c4:	f8 94       	cli
  c6:	de bf       	out	0x3e, r29	; 62
  c8:	0f be       	out	0x3f, r0	; 63
  ca:	cd bf       	out	0x3d, r28	; 61
	unsigned char number4 = 0;
	unsigned char save1 = 1;	//비밀번호
	unsigned char save2 = 1;
	unsigned char save3 = 1;
	unsigned char save4 = 1;
	unsigned char segment3[11] = {
  cc:	8b e0       	ldi	r24, 0x0B	; 11
  ce:	e0 e0       	ldi	r30, 0x00	; 0
  d0:	f1 e0       	ldi	r31, 0x01	; 1
  d2:	de 01       	movw	r26, r28
  d4:	11 96       	adiw	r26, 0x01	; 1
  d6:	01 90       	ld	r0, Z+
  d8:	0d 92       	st	X+, r0
  da:	8a 95       	dec	r24
  dc:	e1 f7       	brne	.-8      	; 0xd6 <main+0x1e>
		0b01101111, //9
		0b10000000	//dot
	};


	DDRD = 0xFF;	//세그먼트 숫자선택
  de:	8f ef       	ldi	r24, 0xFF	; 255
  e0:	81 bb       	out	0x11, r24	; 17
	DDRG = 0xFF;	//세그먼트 전원
  e2:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
	DDRE = 0x0;	//스위치 입력
  e6:	12 b8       	out	0x02, r1	; 2

	PORTD = 0xFF;
  e8:	82 bb       	out	0x12, r24	; 18
	PORTG = 0x0F;
  ea:	8f e0       	ldi	r24, 0x0F	; 15
  ec:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <__TEXT_REGION_LENGTH__+0x7e0065>
	unsigned char number3 = 0;
	unsigned char number4 = 0;
	unsigned char save1 = 1;	//비밀번호
	unsigned char save2 = 1;
	unsigned char save3 = 1;
	unsigned char save4 = 1;
  f0:	a1 e0       	ldi	r26, 0x01	; 1
	unsigned char number2 = 0;
	unsigned char number3 = 0;
	unsigned char number4 = 0;
	unsigned char save1 = 1;	//비밀번호
	unsigned char save2 = 1;
	unsigned char save3 = 1;
  f2:	71 e0       	ldi	r23, 0x01	; 1
	unsigned char number1 = 0;	//입력한 번호
	unsigned char number2 = 0;
	unsigned char number3 = 0;
	unsigned char number4 = 0;
	unsigned char save1 = 1;	//비밀번호
	unsigned char save2 = 1;
  f4:	61 e0       	ldi	r22, 0x01	; 1

	unsigned char number1 = 0;	//입력한 번호
	unsigned char number2 = 0;
	unsigned char number3 = 0;
	unsigned char number4 = 0;
	unsigned char save1 = 1;	//비밀번호
  f6:	51 e0       	ldi	r21, 0x01	; 1
	unsigned char state4 = 0;

	unsigned char number1 = 0;	//입력한 번호
	unsigned char number2 = 0;
	unsigned char number3 = 0;
	unsigned char number4 = 0;
  f8:	b1 2c       	mov	r11, r1
	unsigned char state3 = 0;
	unsigned char state4 = 0;

	unsigned char number1 = 0;	//입력한 번호
	unsigned char number2 = 0;
	unsigned char number3 = 0;
  fa:	c1 2c       	mov	r12, r1
	unsigned char state2 = 0;
	unsigned char state3 = 0;
	unsigned char state4 = 0;

	unsigned char number1 = 0;	//입력한 번호
	unsigned char number2 = 0;
  fc:	d1 2c       	mov	r13, r1
	unsigned char state1 = 0;	//이전 스위치 값
	unsigned char state2 = 0;
	unsigned char state3 = 0;
	unsigned char state4 = 0;

	unsigned char number1 = 0;	//입력한 번호
  fe:	b0 e0       	ldi	r27, 0x00	; 0
{
	unsigned char phase = 0;	//단계변수
	unsigned char state1 = 0;	//이전 스위치 값
	unsigned char state2 = 0;
	unsigned char state3 = 0;
	unsigned char state4 = 0;
 100:	21 2c       	mov	r2, r1
int main(void)
{
	unsigned char phase = 0;	//단계변수
	unsigned char state1 = 0;	//이전 스위치 값
	unsigned char state2 = 0;
	unsigned char state3 = 0;
 102:	40 e0       	ldi	r20, 0x00	; 0

int main(void)
{
	unsigned char phase = 0;	//단계변수
	unsigned char state1 = 0;	//이전 스위치 값
	unsigned char state2 = 0;
 104:	71 2c       	mov	r7, r1


int main(void)
{
	unsigned char phase = 0;	//단계변수
	unsigned char state1 = 0;	//이전 스위치 값
 106:	a1 2c       	mov	r10, r1
#include <util/delay.h>


int main(void)
{
	unsigned char phase = 0;	//단계변수
 108:	91 2c       	mov	r9, r1
				state4 = 0;
			}
		}
		while(phase == 1)	//두번째 숫자단계
		{
			PORTG = 0b00001000;
 10a:	e5 e6       	ldi	r30, 0x65	; 101
 10c:	f0 e0       	ldi	r31, 0x00	; 0
 10e:	68 94       	set
 110:	33 24       	eor	r3, r3
 112:	33 f8       	bld	r3, 3
 114:	33 2d       	mov	r19, r3
			PORTD = ~segment3[number1];
			_delay_ms(5);

			PORTG = 0b00000100;
 116:	94 e0       	ldi	r25, 0x04	; 4
			_delay_ms(5);

			PORTD = ~segment3[10];
			_delay_ms(5);

			PORTG = 0b00000010;
 118:	22 e0       	ldi	r18, 0x02	; 2
			PORTD = ~segment3[number3];
			_delay_ms(5);

			PORTG = 0b00000001;
 11a:	81 e0       	ldi	r24, 0x01	; 1
		{
			PORTG = 0b00001000;
			PORTD = ~segment3[number1];
			_delay_ms(5);

			PORTG = 0b00000100;
 11c:	9e 87       	std	Y+14, r25	; 0x0e
			_delay_ms(5);

			PORTD = ~segment3[10];
			_delay_ms(5);

			PORTG = 0b00000010;
 11e:	2f 87       	std	Y+15, r18	; 0x0f
			PORTD = ~segment3[number3];
			_delay_ms(5);

			PORTG = 0b00000001;
 120:	8c 87       	std	Y+12, r24	; 0x0c
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 122:	61 2c       	mov	r6, r1
			}
		}
		while(phase == 9)	//비밀번호 변경 완료 단계
		{
			PORTG = 0b00001000;
			PORTD = ~(0b00111001);	//네모 표시 출력
 124:	0f 2e       	mov	r0, r31
 126:	f6 ec       	ldi	r31, 0xC6	; 198
 128:	5f 2e       	mov	r5, r31
 12a:	f0 2d       	mov	r31, r0
			_delay_ms(5);
			PORTG = 0b00000100;
			PORTD = ~(0b00001001);
 12c:	16 ef       	ldi	r17, 0xF6	; 246
			_delay_ms(5);
			PORTG = 0b00000010;
			PORTD = ~(0b00001001);
			_delay_ms(5);
			PORTG = 0b00000001;
			PORTD = ~(0b00001111);
 12e:	0f 2e       	mov	r0, r31
 130:	f0 ef       	ldi	r31, 0xF0	; 240
 132:	4f 2e       	mov	r4, r31
 134:	f0 2d       	mov	r31, r0
 136:	b8 8b       	std	Y+16, r27	; 0x10
 138:	dd 86       	std	Y+13, r13	; 0x0d
 13a:	a9 8b       	std	Y+17, r26	; 0x11
 13c:	a0 c0       	rjmp	.+320    	; 0x27e <main+0x1c6>

	while(1)
	{
		while(phase == 0)	//첫번째 숫자 선택단계
		{
			PORTG = 0b00001000;	//첫번째 세그먼트 전원
 13e:	30 82       	st	Z, r3
			PORTD = ~segment3[number1];	//숫자표시
 140:	ee 24       	eor	r14, r14
 142:	e3 94       	inc	r14
 144:	f1 2c       	mov	r15, r1
 146:	ec 0e       	add	r14, r28
 148:	fd 1e       	adc	r15, r29
 14a:	a8 89       	ldd	r26, Y+16	; 0x10
 14c:	ea 0e       	add	r14, r26
 14e:	f1 1c       	adc	r15, r1
 150:	d7 01       	movw	r26, r14
 152:	fc 90       	ld	r15, X
 154:	f0 94       	com	r15
 156:	f2 ba       	out	0x12, r15	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 158:	af e1       	ldi	r26, 0x1F	; 31
 15a:	be e4       	ldi	r27, 0x4E	; 78
 15c:	11 97       	sbiw	r26, 0x01	; 1
 15e:	f1 f7       	brne	.-4      	; 0x15c <main+0xa4>
 160:	00 c0       	rjmp	.+0      	; 0x162 <main+0xaa>
 162:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];	//첫번째 점 표시
 164:	fb 84       	ldd	r15, Y+11	; 0x0b
 166:	f0 94       	com	r15
 168:	f2 ba       	out	0x12, r15	; 18
 16a:	af e1       	ldi	r26, 0x1F	; 31
 16c:	be e4       	ldi	r27, 0x4E	; 78
 16e:	11 97       	sbiw	r26, 0x01	; 1
 170:	f1 f7       	brne	.-4      	; 0x16e <main+0xb6>
 172:	00 c0       	rjmp	.+0      	; 0x174 <main+0xbc>
 174:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 176:	90 83       	st	Z, r25
			PORTD = ~segment3[number2];
 178:	ee 24       	eor	r14, r14
 17a:	e3 94       	inc	r14
 17c:	f1 2c       	mov	r15, r1
 17e:	ec 0e       	add	r14, r28
 180:	fd 1e       	adc	r15, r29
 182:	bd 85       	ldd	r27, Y+13	; 0x0d
 184:	eb 0e       	add	r14, r27
 186:	f1 1c       	adc	r15, r1
 188:	d7 01       	movw	r26, r14
 18a:	fc 90       	ld	r15, X
 18c:	f0 94       	com	r15
 18e:	f2 ba       	out	0x12, r15	; 18
 190:	af e1       	ldi	r26, 0x1F	; 31
 192:	be e4       	ldi	r27, 0x4E	; 78
 194:	11 97       	sbiw	r26, 0x01	; 1
 196:	f1 f7       	brne	.-4      	; 0x194 <main+0xdc>
 198:	00 c0       	rjmp	.+0      	; 0x19a <main+0xe2>
 19a:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 19c:	20 83       	st	Z, r18
			PORTD = ~segment3[number3];
 19e:	ee 24       	eor	r14, r14
 1a0:	e3 94       	inc	r14
 1a2:	f1 2c       	mov	r15, r1
 1a4:	ec 0e       	add	r14, r28
 1a6:	fd 1e       	adc	r15, r29
 1a8:	ec 0c       	add	r14, r12
 1aa:	f1 1c       	adc	r15, r1
 1ac:	d7 01       	movw	r26, r14
 1ae:	fc 90       	ld	r15, X
 1b0:	f0 94       	com	r15
 1b2:	f2 ba       	out	0x12, r15	; 18
 1b4:	af e1       	ldi	r26, 0x1F	; 31
 1b6:	be e4       	ldi	r27, 0x4E	; 78
 1b8:	11 97       	sbiw	r26, 0x01	; 1
 1ba:	f1 f7       	brne	.-4      	; 0x1b8 <main+0x100>
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <main+0x106>
 1be:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 1c0:	80 83       	st	Z, r24
			PORTD = ~segment3[number4];
 1c2:	ee 24       	eor	r14, r14
 1c4:	e3 94       	inc	r14
 1c6:	f1 2c       	mov	r15, r1
 1c8:	ec 0e       	add	r14, r28
 1ca:	fd 1e       	adc	r15, r29
 1cc:	eb 0c       	add	r14, r11
 1ce:	f1 1c       	adc	r15, r1
 1d0:	d7 01       	movw	r26, r14
 1d2:	fc 90       	ld	r15, X
 1d4:	f0 94       	com	r15
 1d6:	f2 ba       	out	0x12, r15	; 18
 1d8:	af e1       	ldi	r26, 0x1F	; 31
 1da:	be e4       	ldi	r27, 0x4E	; 78
 1dc:	11 97       	sbiw	r26, 0x01	; 1
 1de:	f1 f7       	brne	.-4      	; 0x1dc <main+0x124>
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <main+0x12a>
 1e2:	00 00       	nop
			_delay_ms(5);


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
 1e4:	f1 b0       	in	r15, 0x01	; 1
 1e6:	bf 2d       	mov	r27, r15
 1e8:	b0 7f       	andi	r27, 0xF0	; 240
 1ea:	a0 e7       	ldi	r26, 0x70	; 112
 1ec:	ba 13       	cpse	r27, r26
 1ee:	1d c0       	rjmp	.+58     	; 0x22a <main+0x172>
 1f0:	a1 10       	cpse	r10, r1
 1f2:	1b c0       	rjmp	.+54     	; 0x22a <main+0x172>
 1f4:	af e3       	ldi	r26, 0x3F	; 63
 1f6:	bc e9       	ldi	r27, 0x9C	; 156
 1f8:	11 97       	sbiw	r26, 0x01	; 1
 1fa:	f1 f7       	brne	.-4      	; 0x1f8 <main+0x140>
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <main+0x146>
 1fe:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				number1++;	//첫번째 숫자증가
 200:	b8 89       	ldd	r27, Y+16	; 0x10
 202:	bf 5f       	subi	r27, 0xFF	; 255
 204:	b8 8b       	std	Y+16, r27	; 0x10
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
 206:	ba 30       	cpi	r27, 0x0A	; 10
 208:	09 f4       	brne	.+2      	; 0x20c <main+0x154>
 20a:	18 8a       	std	Y+16, r1	; 0x10
				if(number2 == 10) number2 = 0;
 20c:	ad 85       	ldd	r26, Y+13	; 0x0d
 20e:	aa 30       	cpi	r26, 0x0A	; 10
 210:	09 f4       	brne	.+2      	; 0x214 <main+0x15c>
 212:	1d 86       	std	Y+13, r1	; 0x0d
				if(number3 == 10) number3 = 0;
 214:	ba e0       	ldi	r27, 0x0A	; 10
 216:	cb 12       	cpse	r12, r27
 218:	01 c0       	rjmp	.+2      	; 0x21c <main+0x164>
 21a:	c1 2c       	mov	r12, r1
				if(number4 == 10) number4 = 0;
 21c:	aa e0       	ldi	r26, 0x0A	; 10
 21e:	ba 12       	cpse	r11, r26
 220:	03 c0       	rjmp	.+6      	; 0x228 <main+0x170>
 222:	b1 2c       	mov	r11, r1


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
			{
				_delay_ms(10);
				state1 = 1;
 224:	a8 2e       	mov	r10, r24
 226:	01 c0       	rjmp	.+2      	; 0x22a <main+0x172>
 228:	a8 2e       	mov	r10, r24
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
				if(number2 == 10) number2 = 0;
				if(number3 == 10) number3 = 0;
				if(number4 == 10) number4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//2번 스위치 눌렸을때
 22a:	f1 b0       	in	r15, 0x01	; 1
 22c:	bf 2d       	mov	r27, r15
 22e:	b0 7f       	andi	r27, 0xF0	; 240
 230:	a0 eb       	ldi	r26, 0xB0	; 176
 232:	ba 13       	cpse	r27, r26
 234:	0a c0       	rjmp	.+20     	; 0x24a <main+0x192>
 236:	71 10       	cpse	r7, r1
 238:	08 c0       	rjmp	.+16     	; 0x24a <main+0x192>
 23a:	af e3       	ldi	r26, 0x3F	; 63
 23c:	bc e9       	ldi	r27, 0x9C	; 156
 23e:	11 97       	sbiw	r26, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <main+0x186>
 242:	00 c0       	rjmp	.+0      	; 0x244 <main+0x18c>
 244:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 246:	78 2e       	mov	r7, r24
				phase = 1;	//다음단계로 이동
 248:	98 2e       	mov	r9, r24
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
 24a:	f1 b0       	in	r15, 0x01	; 1
 24c:	bf 2d       	mov	r27, r15
 24e:	b0 7f       	andi	r27, 0xF0	; 240
 250:	a0 ed       	ldi	r26, 0xD0	; 208
 252:	ba 13       	cpse	r27, r26
 254:	0a c0       	rjmp	.+20     	; 0x26a <main+0x1b2>
 256:	41 11       	cpse	r20, r1
 258:	08 c0       	rjmp	.+16     	; 0x26a <main+0x1b2>
 25a:	af e3       	ldi	r26, 0x3F	; 63
 25c:	bc e9       	ldi	r27, 0x9C	; 156
 25e:	11 97       	sbiw	r26, 0x01	; 1
 260:	f1 f7       	brne	.-4      	; 0x25e <main+0x1a6>
 262:	00 c0       	rjmp	.+0      	; 0x264 <main+0x1ac>
 264:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
 266:	48 2f       	mov	r20, r24
				phase = 4;	//비밀번호 확인단계로
 268:	99 2e       	mov	r9, r25
			}
			if((PINE & 0xF0) == 0xF0)
 26a:	f1 b0       	in	r15, 0x01	; 1
 26c:	bf 2d       	mov	r27, r15
 26e:	b0 7f       	andi	r27, 0xF0	; 240
 270:	a0 ef       	ldi	r26, 0xF0	; 240
 272:	ba 13       	cpse	r27, r26
 274:	04 c0       	rjmp	.+8      	; 0x27e <main+0x1c6>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 276:	21 2c       	mov	r2, r1
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 278:	40 e0       	ldi	r20, 0x00	; 0
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 27a:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 27c:	a1 2c       	mov	r10, r1
	PORTD = 0xFF;
	PORTG = 0x0F;

	while(1)
	{
		while(phase == 0)	//첫번째 숫자 선택단계
 27e:	99 20       	and	r9, r9
 280:	09 f4       	brne	.+2      	; 0x284 <main+0x1cc>
 282:	5d cf       	rjmp	.-326    	; 0x13e <main+0x86>
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 1)	//두번째 숫자단계
 284:	b1 e0       	ldi	r27, 0x01	; 1
 286:	9b 12       	cpse	r9, r27
 288:	ad c0       	rjmp	.+346    	; 0x3e4 <main+0x32c>
 28a:	d5 2e       	mov	r13, r21
 28c:	5d 85       	ldd	r21, Y+13	; 0x0d
 28e:	f6 2e       	mov	r15, r22
 290:	68 89       	ldd	r22, Y+16	; 0x10
 292:	07 2f       	mov	r16, r23
 294:	79 89       	ldd	r23, Y+17	; 0x11
		{
			PORTG = 0b00001000;
 296:	30 83       	st	Z, r19
			PORTD = ~segment3[number1];
 298:	a1 e0       	ldi	r26, 0x01	; 1
 29a:	b0 e0       	ldi	r27, 0x00	; 0
 29c:	ac 0f       	add	r26, r28
 29e:	bd 1f       	adc	r27, r29
 2a0:	a6 0f       	add	r26, r22
 2a2:	b1 1d       	adc	r27, r1
 2a4:	ac 91       	ld	r26, X
 2a6:	a0 95       	com	r26
 2a8:	a2 bb       	out	0x12, r26	; 18
 2aa:	af e1       	ldi	r26, 0x1F	; 31
 2ac:	be e4       	ldi	r27, 0x4E	; 78
 2ae:	11 97       	sbiw	r26, 0x01	; 1
 2b0:	f1 f7       	brne	.-4      	; 0x2ae <main+0x1f6>
 2b2:	00 c0       	rjmp	.+0      	; 0x2b4 <main+0x1fc>
 2b4:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 2b6:	90 83       	st	Z, r25
			PORTD = ~segment3[number2];
 2b8:	a1 e0       	ldi	r26, 0x01	; 1
 2ba:	b0 e0       	ldi	r27, 0x00	; 0
 2bc:	ac 0f       	add	r26, r28
 2be:	bd 1f       	adc	r27, r29
 2c0:	a5 0f       	add	r26, r21
 2c2:	b1 1d       	adc	r27, r1
 2c4:	ac 91       	ld	r26, X
 2c6:	a0 95       	com	r26
 2c8:	a2 bb       	out	0x12, r26	; 18
 2ca:	af e1       	ldi	r26, 0x1F	; 31
 2cc:	be e4       	ldi	r27, 0x4E	; 78
 2ce:	11 97       	sbiw	r26, 0x01	; 1
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <main+0x216>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <main+0x21c>
 2d4:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 2d6:	ab 85       	ldd	r26, Y+11	; 0x0b
 2d8:	a0 95       	com	r26
 2da:	a2 bb       	out	0x12, r26	; 18
 2dc:	af e1       	ldi	r26, 0x1F	; 31
 2de:	be e4       	ldi	r27, 0x4E	; 78
 2e0:	11 97       	sbiw	r26, 0x01	; 1
 2e2:	f1 f7       	brne	.-4      	; 0x2e0 <main+0x228>
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <main+0x22e>
 2e6:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 2e8:	20 83       	st	Z, r18
			PORTD = ~segment3[number3];
 2ea:	a1 e0       	ldi	r26, 0x01	; 1
 2ec:	b0 e0       	ldi	r27, 0x00	; 0
 2ee:	ac 0f       	add	r26, r28
 2f0:	bd 1f       	adc	r27, r29
 2f2:	ac 0d       	add	r26, r12
 2f4:	b1 1d       	adc	r27, r1
 2f6:	ac 91       	ld	r26, X
 2f8:	a0 95       	com	r26
 2fa:	a2 bb       	out	0x12, r26	; 18
 2fc:	af e1       	ldi	r26, 0x1F	; 31
 2fe:	be e4       	ldi	r27, 0x4E	; 78
 300:	11 97       	sbiw	r26, 0x01	; 1
 302:	f1 f7       	brne	.-4      	; 0x300 <main+0x248>
 304:	00 c0       	rjmp	.+0      	; 0x306 <main+0x24e>
 306:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 308:	80 83       	st	Z, r24
			PORTD = ~segment3[number4];
 30a:	a1 e0       	ldi	r26, 0x01	; 1
 30c:	b0 e0       	ldi	r27, 0x00	; 0
 30e:	ac 0f       	add	r26, r28
 310:	bd 1f       	adc	r27, r29
 312:	ab 0d       	add	r26, r11
 314:	b1 1d       	adc	r27, r1
 316:	ac 91       	ld	r26, X
 318:	a0 95       	com	r26
 31a:	a2 bb       	out	0x12, r26	; 18
 31c:	af e1       	ldi	r26, 0x1F	; 31
 31e:	be e4       	ldi	r27, 0x4E	; 78
 320:	11 97       	sbiw	r26, 0x01	; 1
 322:	f1 f7       	brne	.-4      	; 0x320 <main+0x268>
 324:	00 c0       	rjmp	.+0      	; 0x326 <main+0x26e>
 326:	00 00       	nop
			_delay_ms(5);


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
 328:	a1 b1       	in	r26, 0x01	; 1
 32a:	a0 7f       	andi	r26, 0xF0	; 240
 32c:	a0 37       	cpi	r26, 0x70	; 112
 32e:	d1 f4       	brne	.+52     	; 0x364 <main+0x2ac>
 330:	a1 10       	cpse	r10, r1
 332:	18 c0       	rjmp	.+48     	; 0x364 <main+0x2ac>
 334:	af e3       	ldi	r26, 0x3F	; 63
 336:	bc e9       	ldi	r27, 0x9C	; 156
 338:	11 97       	sbiw	r26, 0x01	; 1
 33a:	f1 f7       	brne	.-4      	; 0x338 <main+0x280>
 33c:	00 c0       	rjmp	.+0      	; 0x33e <main+0x286>
 33e:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				number2++;	//두번째 숫자증가
 340:	5f 5f       	subi	r21, 0xFF	; 255
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
 342:	6a 30       	cpi	r22, 0x0A	; 10
 344:	09 f4       	brne	.+2      	; 0x348 <main+0x290>
 346:	60 e0       	ldi	r22, 0x00	; 0
				if(number2 == 10) number2 = 0;
 348:	5a 30       	cpi	r21, 0x0A	; 10
 34a:	09 f4       	brne	.+2      	; 0x34e <main+0x296>
 34c:	50 e0       	ldi	r21, 0x00	; 0
				if(number3 == 10) number3 = 0;
 34e:	ba e0       	ldi	r27, 0x0A	; 10
 350:	cb 12       	cpse	r12, r27
 352:	01 c0       	rjmp	.+2      	; 0x356 <main+0x29e>
 354:	c1 2c       	mov	r12, r1
				if(number4 == 10) number4 = 0;
 356:	aa e0       	ldi	r26, 0x0A	; 10
 358:	ba 12       	cpse	r11, r26
 35a:	03 c0       	rjmp	.+6      	; 0x362 <main+0x2aa>
 35c:	b1 2c       	mov	r11, r1


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
			{
				_delay_ms(10);
				state1 = 1;
 35e:	ac 84       	ldd	r10, Y+12	; 0x0c
 360:	01 c0       	rjmp	.+2      	; 0x364 <main+0x2ac>
 362:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
				if(number2 == 10) number2 = 0;
				if(number3 == 10) number3 = 0;
				if(number4 == 10) number4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//2번 스위치 눌렸을때
 364:	a1 b1       	in	r26, 0x01	; 1
 366:	a0 7f       	andi	r26, 0xF0	; 240
 368:	a0 3b       	cpi	r26, 0xB0	; 176
 36a:	59 f4       	brne	.+22     	; 0x382 <main+0x2ca>
 36c:	71 10       	cpse	r7, r1
 36e:	0b c0       	rjmp	.+22     	; 0x386 <main+0x2ce>
 370:	af e3       	ldi	r26, 0x3F	; 63
 372:	bc e9       	ldi	r27, 0x9C	; 156
 374:	11 97       	sbiw	r26, 0x01	; 1
 376:	f1 f7       	brne	.-4      	; 0x374 <main+0x2bc>
 378:	00 c0       	rjmp	.+0      	; 0x37a <main+0x2c2>
 37a:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 37c:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 2;	//다음단계로 이동
 37e:	bf 85       	ldd	r27, Y+15	; 0x0f
 380:	03 c0       	rjmp	.+6      	; 0x388 <main+0x2d0>
 382:	b9 2d       	mov	r27, r9
 384:	01 c0       	rjmp	.+2      	; 0x388 <main+0x2d0>
 386:	b9 2d       	mov	r27, r9
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
 388:	a1 b1       	in	r26, 0x01	; 1
 38a:	a0 7f       	andi	r26, 0xF0	; 240
 38c:	a0 3d       	cpi	r26, 0xD0	; 208
 38e:	c1 f4       	brne	.+48     	; 0x3c0 <main+0x308>
 390:	41 11       	cpse	r20, r1
 392:	16 c0       	rjmp	.+44     	; 0x3c0 <main+0x308>
 394:	68 8b       	std	Y+16, r22	; 0x10
 396:	5d 87       	std	Y+13, r21	; 0x0d
 398:	5d 2d       	mov	r21, r13
 39a:	6f 2d       	mov	r22, r15
 39c:	79 8b       	std	Y+17, r23	; 0x11
 39e:	70 2f       	mov	r23, r16
 3a0:	af e3       	ldi	r26, 0x3F	; 63
 3a2:	bc e9       	ldi	r27, 0x9C	; 156
 3a4:	11 97       	sbiw	r26, 0x01	; 1
 3a6:	f1 f7       	brne	.-4      	; 0x3a4 <main+0x2ec>
 3a8:	00 c0       	rjmp	.+0      	; 0x3aa <main+0x2f2>
 3aa:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 3ac:	f1 b0       	in	r15, 0x01	; 1
 3ae:	bf 2d       	mov	r27, r15
 3b0:	b0 7f       	andi	r27, 0xF0	; 240
 3b2:	a0 ef       	ldi	r26, 0xF0	; 240
 3b4:	ba 17       	cp	r27, r26
 3b6:	09 f4       	brne	.+2      	; 0x3ba <main+0x302>
 3b8:	cb c0       	rjmp	.+406    	; 0x550 <__LOCK_REGION_LENGTH__+0x150>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
 3ba:	99 2e       	mov	r9, r25
				phase = 2;	//다음단계로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
 3bc:	48 2f       	mov	r20, r24
 3be:	12 c0       	rjmp	.+36     	; 0x3e4 <main+0x32c>
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 3c0:	a1 b1       	in	r26, 0x01	; 1
 3c2:	a0 7f       	andi	r26, 0xF0	; 240
 3c4:	a0 3f       	cpi	r26, 0xF0	; 240
 3c6:	21 f4       	brne	.+8      	; 0x3d0 <main+0x318>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 3c8:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 3ca:	46 2d       	mov	r20, r6
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 3cc:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 3ce:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 1)	//두번째 숫자단계
 3d0:	b1 30       	cpi	r27, 0x01	; 1
 3d2:	09 f4       	brne	.+2      	; 0x3d6 <main+0x31e>
 3d4:	60 cf       	rjmp	.-320    	; 0x296 <main+0x1de>
 3d6:	68 8b       	std	Y+16, r22	; 0x10
 3d8:	5d 87       	std	Y+13, r21	; 0x0d
 3da:	5d 2d       	mov	r21, r13
 3dc:	6f 2d       	mov	r22, r15
 3de:	79 8b       	std	Y+17, r23	; 0x11
 3e0:	70 2f       	mov	r23, r16
 3e2:	9b 2e       	mov	r9, r27
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 2)	//세번째 숫자 단계
 3e4:	b2 e0       	ldi	r27, 0x02	; 2
 3e6:	9b 12       	cpse	r9, r27
 3e8:	b7 c0       	rjmp	.+366    	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
 3ea:	d9 2c       	mov	r13, r9
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//2번 스위치 눌렸을때
			{
				_delay_ms(10);
				state2 = 1;
				phase = 3;	//다음단계로 이동
 3ec:	0f 2e       	mov	r0, r31
 3ee:	f3 e0       	ldi	r31, 0x03	; 3
 3f0:	8f 2e       	mov	r8, r31
 3f2:	f0 2d       	mov	r31, r0
 3f4:	e5 2e       	mov	r14, r21
 3f6:	58 89       	ldd	r21, Y+16	; 0x10
 3f8:	f6 2e       	mov	r15, r22
 3fa:	6d 85       	ldd	r22, Y+13	; 0x0d
 3fc:	07 2f       	mov	r16, r23
 3fe:	79 89       	ldd	r23, Y+17	; 0x11
				state4 = 0;
			}
		}
		while(phase == 2)	//세번째 숫자 단계
		{
			PORTG = 0b00001000;
 400:	30 83       	st	Z, r19
			PORTD = ~segment3[number1];
 402:	a1 e0       	ldi	r26, 0x01	; 1
 404:	b0 e0       	ldi	r27, 0x00	; 0
 406:	ac 0f       	add	r26, r28
 408:	bd 1f       	adc	r27, r29
 40a:	a5 0f       	add	r26, r21
 40c:	b1 1d       	adc	r27, r1
 40e:	ac 91       	ld	r26, X
 410:	a0 95       	com	r26
 412:	a2 bb       	out	0x12, r26	; 18
 414:	af e1       	ldi	r26, 0x1F	; 31
 416:	be e4       	ldi	r27, 0x4E	; 78
 418:	11 97       	sbiw	r26, 0x01	; 1
 41a:	f1 f7       	brne	.-4      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 41c:	00 c0       	rjmp	.+0      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 41e:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 420:	90 83       	st	Z, r25
			PORTD = ~segment3[number2];
 422:	a1 e0       	ldi	r26, 0x01	; 1
 424:	b0 e0       	ldi	r27, 0x00	; 0
 426:	ac 0f       	add	r26, r28
 428:	bd 1f       	adc	r27, r29
 42a:	a6 0f       	add	r26, r22
 42c:	b1 1d       	adc	r27, r1
 42e:	ac 91       	ld	r26, X
 430:	a0 95       	com	r26
 432:	a2 bb       	out	0x12, r26	; 18
 434:	af e1       	ldi	r26, 0x1F	; 31
 436:	be e4       	ldi	r27, 0x4E	; 78
 438:	11 97       	sbiw	r26, 0x01	; 1
 43a:	f1 f7       	brne	.-4      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
 43c:	00 c0       	rjmp	.+0      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
 43e:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 440:	20 83       	st	Z, r18
			PORTD = ~segment3[number3];
 442:	a1 e0       	ldi	r26, 0x01	; 1
 444:	b0 e0       	ldi	r27, 0x00	; 0
 446:	ac 0f       	add	r26, r28
 448:	bd 1f       	adc	r27, r29
 44a:	ac 0d       	add	r26, r12
 44c:	b1 1d       	adc	r27, r1
 44e:	ac 91       	ld	r26, X
 450:	a0 95       	com	r26
 452:	a2 bb       	out	0x12, r26	; 18
 454:	af e1       	ldi	r26, 0x1F	; 31
 456:	be e4       	ldi	r27, 0x4E	; 78
 458:	11 97       	sbiw	r26, 0x01	; 1
 45a:	f1 f7       	brne	.-4      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 45c:	00 c0       	rjmp	.+0      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
 45e:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 460:	ab 85       	ldd	r26, Y+11	; 0x0b
 462:	a0 95       	com	r26
 464:	a2 bb       	out	0x12, r26	; 18
 466:	af e1       	ldi	r26, 0x1F	; 31
 468:	be e4       	ldi	r27, 0x4E	; 78
 46a:	11 97       	sbiw	r26, 0x01	; 1
 46c:	f1 f7       	brne	.-4      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 46e:	00 c0       	rjmp	.+0      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 470:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 472:	80 83       	st	Z, r24
			PORTD = ~segment3[number4];
 474:	a1 e0       	ldi	r26, 0x01	; 1
 476:	b0 e0       	ldi	r27, 0x00	; 0
 478:	ac 0f       	add	r26, r28
 47a:	bd 1f       	adc	r27, r29
 47c:	ab 0d       	add	r26, r11
 47e:	b1 1d       	adc	r27, r1
 480:	ac 91       	ld	r26, X
 482:	a0 95       	com	r26
 484:	a2 bb       	out	0x12, r26	; 18
 486:	af e1       	ldi	r26, 0x1F	; 31
 488:	be e4       	ldi	r27, 0x4E	; 78
 48a:	11 97       	sbiw	r26, 0x01	; 1
 48c:	f1 f7       	brne	.-4      	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
 48e:	00 c0       	rjmp	.+0      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
 490:	00 00       	nop
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
 492:	a1 b1       	in	r26, 0x01	; 1
 494:	a0 7f       	andi	r26, 0xF0	; 240
 496:	a0 37       	cpi	r26, 0x70	; 112
 498:	d1 f4       	brne	.+52     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
 49a:	a1 10       	cpse	r10, r1
 49c:	18 c0       	rjmp	.+48     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
 49e:	af e3       	ldi	r26, 0x3F	; 63
 4a0:	bc e9       	ldi	r27, 0x9C	; 156
 4a2:	11 97       	sbiw	r26, 0x01	; 1
 4a4:	f1 f7       	brne	.-4      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
 4a6:	00 c0       	rjmp	.+0      	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
 4a8:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				number3++;	//세번째 숫자증가
 4aa:	c3 94       	inc	r12
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
 4ac:	5a 30       	cpi	r21, 0x0A	; 10
 4ae:	09 f4       	brne	.+2      	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
 4b0:	50 e0       	ldi	r21, 0x00	; 0
				if(number2 == 10) number2 = 0;
 4b2:	6a 30       	cpi	r22, 0x0A	; 10
 4b4:	09 f4       	brne	.+2      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
 4b6:	60 e0       	ldi	r22, 0x00	; 0
				if(number3 == 10) number3 = 0;
 4b8:	ba e0       	ldi	r27, 0x0A	; 10
 4ba:	cb 12       	cpse	r12, r27
 4bc:	01 c0       	rjmp	.+2      	; 0x4c0 <__LOCK_REGION_LENGTH__+0xc0>
 4be:	c1 2c       	mov	r12, r1
				if(number4 == 10) number4 = 0;
 4c0:	aa e0       	ldi	r26, 0x0A	; 10
 4c2:	ba 12       	cpse	r11, r26
 4c4:	03 c0       	rjmp	.+6      	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
 4c6:	b1 2c       	mov	r11, r1
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
			{
				_delay_ms(10);
				state1 = 1;
 4c8:	ac 84       	ldd	r10, Y+12	; 0x0c
 4ca:	01 c0       	rjmp	.+2      	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
 4cc:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
				if(number2 == 10) number2 = 0;
				if(number3 == 10) number3 = 0;
				if(number4 == 10) number4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//2번 스위치 눌렸을때
 4ce:	a1 b1       	in	r26, 0x01	; 1
 4d0:	a0 7f       	andi	r26, 0xF0	; 240
 4d2:	a0 3b       	cpi	r26, 0xB0	; 176
 4d4:	59 f4       	brne	.+22     	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
 4d6:	71 10       	cpse	r7, r1
 4d8:	0b c0       	rjmp	.+22     	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
 4da:	af e3       	ldi	r26, 0x3F	; 63
 4dc:	bc e9       	ldi	r27, 0x9C	; 156
 4de:	11 97       	sbiw	r26, 0x01	; 1
 4e0:	f1 f7       	brne	.-4      	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
 4e2:	00 c0       	rjmp	.+0      	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>
 4e4:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 4e6:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 3;	//다음단계로 이동
 4e8:	b8 2d       	mov	r27, r8
 4ea:	03 c0       	rjmp	.+6      	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
 4ec:	bd 2d       	mov	r27, r13
 4ee:	01 c0       	rjmp	.+2      	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
 4f0:	bd 2d       	mov	r27, r13
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
 4f2:	a1 b1       	in	r26, 0x01	; 1
 4f4:	a0 7f       	andi	r26, 0xF0	; 240
 4f6:	a0 3d       	cpi	r26, 0xD0	; 208
 4f8:	c1 f4       	brne	.+48     	; 0x52a <__LOCK_REGION_LENGTH__+0x12a>
 4fa:	41 11       	cpse	r20, r1
 4fc:	16 c0       	rjmp	.+44     	; 0x52a <__LOCK_REGION_LENGTH__+0x12a>
 4fe:	58 8b       	std	Y+16, r21	; 0x10
 500:	6d 87       	std	Y+13, r22	; 0x0d
 502:	5e 2d       	mov	r21, r14
 504:	6f 2d       	mov	r22, r15
 506:	79 8b       	std	Y+17, r23	; 0x11
 508:	70 2f       	mov	r23, r16
 50a:	af e3       	ldi	r26, 0x3F	; 63
 50c:	bc e9       	ldi	r27, 0x9C	; 156
 50e:	11 97       	sbiw	r26, 0x01	; 1
 510:	f1 f7       	brne	.-4      	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
 512:	00 c0       	rjmp	.+0      	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
 514:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 516:	f1 b0       	in	r15, 0x01	; 1
 518:	bf 2d       	mov	r27, r15
 51a:	b0 7f       	andi	r27, 0xF0	; 240
 51c:	a0 ef       	ldi	r26, 0xF0	; 240
 51e:	ba 17       	cp	r27, r26
 520:	09 f4       	brne	.+2      	; 0x524 <__LOCK_REGION_LENGTH__+0x124>
 522:	ca c0       	rjmp	.+404    	; 0x6b8 <__LOCK_REGION_LENGTH__+0x2b8>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
 524:	99 2e       	mov	r9, r25
				phase = 3;	//다음단계로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
 526:	48 2f       	mov	r20, r24
 528:	17 c0       	rjmp	.+46     	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 52a:	a1 b1       	in	r26, 0x01	; 1
 52c:	a0 7f       	andi	r26, 0xF0	; 240
 52e:	a0 3f       	cpi	r26, 0xF0	; 240
 530:	21 f4       	brne	.+8      	; 0x53a <__LOCK_REGION_LENGTH__+0x13a>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 532:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 534:	46 2d       	mov	r20, r6
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 536:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 538:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 2)	//세번째 숫자 단계
 53a:	b2 30       	cpi	r27, 0x02	; 2
 53c:	09 f4       	brne	.+2      	; 0x540 <__LOCK_REGION_LENGTH__+0x140>
 53e:	60 cf       	rjmp	.-320    	; 0x400 <__LOCK_REGION_LENGTH__>
 540:	6d 87       	std	Y+13, r22	; 0x0d
 542:	6f 2d       	mov	r22, r15
 544:	79 8b       	std	Y+17, r23	; 0x11
 546:	70 2f       	mov	r23, r16
 548:	9b 2e       	mov	r9, r27
 54a:	58 8b       	std	Y+16, r21	; 0x10
 54c:	5e 2d       	mov	r21, r14
 54e:	04 c0       	rjmp	.+8      	; 0x558 <__LOCK_REGION_LENGTH__+0x158>
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 550:	21 2c       	mov	r2, r1
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 552:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 554:	a1 2c       	mov	r10, r1
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
 556:	99 2e       	mov	r9, r25
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 3)	//4번째 숫자 단계
 558:	b3 e0       	ldi	r27, 0x03	; 3
 55a:	9b 12       	cpse	r9, r27
 55c:	b2 c0       	rjmp	.+356    	; 0x6c2 <__LOCK_REGION_LENGTH__+0x2c2>
 55e:	d5 2e       	mov	r13, r21
 560:	58 89       	ldd	r21, Y+16	; 0x10
 562:	e6 2e       	mov	r14, r22
 564:	6d 85       	ldd	r22, Y+13	; 0x0d
 566:	07 2f       	mov	r16, r23
 568:	79 89       	ldd	r23, Y+17	; 0x11
		{
			PORTG = 0b00001000;
 56a:	30 83       	st	Z, r19
			PORTD = ~segment3[number1];
 56c:	a1 e0       	ldi	r26, 0x01	; 1
 56e:	b0 e0       	ldi	r27, 0x00	; 0
 570:	ac 0f       	add	r26, r28
 572:	bd 1f       	adc	r27, r29
 574:	a5 0f       	add	r26, r21
 576:	b1 1d       	adc	r27, r1
 578:	ac 91       	ld	r26, X
 57a:	a0 95       	com	r26
 57c:	a2 bb       	out	0x12, r26	; 18
 57e:	af e1       	ldi	r26, 0x1F	; 31
 580:	be e4       	ldi	r27, 0x4E	; 78
 582:	11 97       	sbiw	r26, 0x01	; 1
 584:	f1 f7       	brne	.-4      	; 0x582 <__LOCK_REGION_LENGTH__+0x182>
 586:	00 c0       	rjmp	.+0      	; 0x588 <__LOCK_REGION_LENGTH__+0x188>
 588:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 58a:	90 83       	st	Z, r25
			PORTD = ~segment3[number2];
 58c:	a1 e0       	ldi	r26, 0x01	; 1
 58e:	b0 e0       	ldi	r27, 0x00	; 0
 590:	ac 0f       	add	r26, r28
 592:	bd 1f       	adc	r27, r29
 594:	a6 0f       	add	r26, r22
 596:	b1 1d       	adc	r27, r1
 598:	ac 91       	ld	r26, X
 59a:	a0 95       	com	r26
 59c:	a2 bb       	out	0x12, r26	; 18
 59e:	af e1       	ldi	r26, 0x1F	; 31
 5a0:	be e4       	ldi	r27, 0x4E	; 78
 5a2:	11 97       	sbiw	r26, 0x01	; 1
 5a4:	f1 f7       	brne	.-4      	; 0x5a2 <__LOCK_REGION_LENGTH__+0x1a2>
 5a6:	00 c0       	rjmp	.+0      	; 0x5a8 <__LOCK_REGION_LENGTH__+0x1a8>
 5a8:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 5aa:	20 83       	st	Z, r18
			PORTD = ~segment3[number3];
 5ac:	a1 e0       	ldi	r26, 0x01	; 1
 5ae:	b0 e0       	ldi	r27, 0x00	; 0
 5b0:	ac 0f       	add	r26, r28
 5b2:	bd 1f       	adc	r27, r29
 5b4:	ac 0d       	add	r26, r12
 5b6:	b1 1d       	adc	r27, r1
 5b8:	ac 91       	ld	r26, X
 5ba:	a0 95       	com	r26
 5bc:	a2 bb       	out	0x12, r26	; 18
 5be:	af e1       	ldi	r26, 0x1F	; 31
 5c0:	be e4       	ldi	r27, 0x4E	; 78
 5c2:	11 97       	sbiw	r26, 0x01	; 1
 5c4:	f1 f7       	brne	.-4      	; 0x5c2 <__LOCK_REGION_LENGTH__+0x1c2>
 5c6:	00 c0       	rjmp	.+0      	; 0x5c8 <__LOCK_REGION_LENGTH__+0x1c8>
 5c8:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 5ca:	80 83       	st	Z, r24
			PORTD = ~segment3[number4];
 5cc:	a1 e0       	ldi	r26, 0x01	; 1
 5ce:	b0 e0       	ldi	r27, 0x00	; 0
 5d0:	ac 0f       	add	r26, r28
 5d2:	bd 1f       	adc	r27, r29
 5d4:	ab 0d       	add	r26, r11
 5d6:	b1 1d       	adc	r27, r1
 5d8:	ac 91       	ld	r26, X
 5da:	a0 95       	com	r26
 5dc:	a2 bb       	out	0x12, r26	; 18
 5de:	af e1       	ldi	r26, 0x1F	; 31
 5e0:	be e4       	ldi	r27, 0x4E	; 78
 5e2:	11 97       	sbiw	r26, 0x01	; 1
 5e4:	f1 f7       	brne	.-4      	; 0x5e2 <__LOCK_REGION_LENGTH__+0x1e2>
 5e6:	00 c0       	rjmp	.+0      	; 0x5e8 <__LOCK_REGION_LENGTH__+0x1e8>
 5e8:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 5ea:	ab 85       	ldd	r26, Y+11	; 0x0b
 5ec:	a0 95       	com	r26
 5ee:	a2 bb       	out	0x12, r26	; 18
 5f0:	af e1       	ldi	r26, 0x1F	; 31
 5f2:	be e4       	ldi	r27, 0x4E	; 78
 5f4:	11 97       	sbiw	r26, 0x01	; 1
 5f6:	f1 f7       	brne	.-4      	; 0x5f4 <__LOCK_REGION_LENGTH__+0x1f4>
 5f8:	00 c0       	rjmp	.+0      	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
 5fa:	00 00       	nop
			_delay_ms(5);


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
 5fc:	a1 b1       	in	r26, 0x01	; 1
 5fe:	a0 7f       	andi	r26, 0xF0	; 240
 600:	a0 37       	cpi	r26, 0x70	; 112
 602:	d1 f4       	brne	.+52     	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
 604:	a1 10       	cpse	r10, r1
 606:	18 c0       	rjmp	.+48     	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
 608:	af e3       	ldi	r26, 0x3F	; 63
 60a:	bc e9       	ldi	r27, 0x9C	; 156
 60c:	11 97       	sbiw	r26, 0x01	; 1
 60e:	f1 f7       	brne	.-4      	; 0x60c <__LOCK_REGION_LENGTH__+0x20c>
 610:	00 c0       	rjmp	.+0      	; 0x612 <__LOCK_REGION_LENGTH__+0x212>
 612:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				number4++;	//네번째 숫자증가
 614:	b3 94       	inc	r11
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
 616:	5a 30       	cpi	r21, 0x0A	; 10
 618:	09 f4       	brne	.+2      	; 0x61c <__LOCK_REGION_LENGTH__+0x21c>
 61a:	50 e0       	ldi	r21, 0x00	; 0
				if(number2 == 10) number2 = 0;
 61c:	6a 30       	cpi	r22, 0x0A	; 10
 61e:	09 f4       	brne	.+2      	; 0x622 <__LOCK_REGION_LENGTH__+0x222>
 620:	60 e0       	ldi	r22, 0x00	; 0
				if(number3 == 10) number3 = 0;
 622:	ba e0       	ldi	r27, 0x0A	; 10
 624:	cb 12       	cpse	r12, r27
 626:	01 c0       	rjmp	.+2      	; 0x62a <__LOCK_REGION_LENGTH__+0x22a>
 628:	c1 2c       	mov	r12, r1
				if(number4 == 10) number4 = 0;
 62a:	aa e0       	ldi	r26, 0x0A	; 10
 62c:	ba 12       	cpse	r11, r26
 62e:	03 c0       	rjmp	.+6      	; 0x636 <__LOCK_REGION_LENGTH__+0x236>
 630:	b1 2c       	mov	r11, r1


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//1번 스위치 눌렸을때
			{
				_delay_ms(10);
				state1 = 1;
 632:	ac 84       	ldd	r10, Y+12	; 0x0c
 634:	01 c0       	rjmp	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
 636:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(number1 == 10) number1 = 0; //10일때 다시 0으로
				if(number2 == 10) number2 = 0;
				if(number3 == 10) number3 = 0;
				if(number4 == 10) number4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//2번 스위치 눌렸을때
 638:	a1 b1       	in	r26, 0x01	; 1
 63a:	a0 7f       	andi	r26, 0xF0	; 240
 63c:	a0 3b       	cpi	r26, 0xB0	; 176
 63e:	59 f4       	brne	.+22     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
 640:	71 10       	cpse	r7, r1
 642:	0b c0       	rjmp	.+22     	; 0x65a <__LOCK_REGION_LENGTH__+0x25a>
 644:	af e3       	ldi	r26, 0x3F	; 63
 646:	bc e9       	ldi	r27, 0x9C	; 156
 648:	11 97       	sbiw	r26, 0x01	; 1
 64a:	f1 f7       	brne	.-4      	; 0x648 <__LOCK_REGION_LENGTH__+0x248>
 64c:	00 c0       	rjmp	.+0      	; 0x64e <__LOCK_REGION_LENGTH__+0x24e>
 64e:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 650:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 0;	//처음단계로 이동
 652:	b6 2d       	mov	r27, r6
 654:	03 c0       	rjmp	.+6      	; 0x65c <__LOCK_REGION_LENGTH__+0x25c>
 656:	b9 2d       	mov	r27, r9
 658:	01 c0       	rjmp	.+2      	; 0x65c <__LOCK_REGION_LENGTH__+0x25c>
 65a:	b9 2d       	mov	r27, r9
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
 65c:	a1 b1       	in	r26, 0x01	; 1
 65e:	a0 7f       	andi	r26, 0xF0	; 240
 660:	a0 3d       	cpi	r26, 0xD0	; 208
 662:	b9 f4       	brne	.+46     	; 0x692 <__LOCK_REGION_LENGTH__+0x292>
 664:	41 11       	cpse	r20, r1
 666:	15 c0       	rjmp	.+42     	; 0x692 <__LOCK_REGION_LENGTH__+0x292>
 668:	58 8b       	std	Y+16, r21	; 0x10
 66a:	6d 87       	std	Y+13, r22	; 0x0d
 66c:	5d 2d       	mov	r21, r13
 66e:	6e 2d       	mov	r22, r14
 670:	79 8b       	std	Y+17, r23	; 0x11
 672:	70 2f       	mov	r23, r16
 674:	af e3       	ldi	r26, 0x3F	; 63
 676:	bc e9       	ldi	r27, 0x9C	; 156
 678:	11 97       	sbiw	r26, 0x01	; 1
 67a:	f1 f7       	brne	.-4      	; 0x678 <__LOCK_REGION_LENGTH__+0x278>
 67c:	00 c0       	rjmp	.+0      	; 0x67e <__LOCK_REGION_LENGTH__+0x27e>
 67e:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 680:	f1 b0       	in	r15, 0x01	; 1
 682:	bf 2d       	mov	r27, r15
 684:	b0 7f       	andi	r27, 0xF0	; 240
 686:	a0 ef       	ldi	r26, 0xF0	; 240
 688:	ba 17       	cp	r27, r26
 68a:	01 f1       	breq	.+64     	; 0x6cc <__LOCK_REGION_LENGTH__+0x2cc>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
 68c:	f9 2e       	mov	r15, r25
				phase = 0;	//처음단계로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
 68e:	48 2f       	mov	r20, r24
 690:	19 c0       	rjmp	.+50     	; 0x6c4 <__LOCK_REGION_LENGTH__+0x2c4>
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
 692:	a1 b1       	in	r26, 0x01	; 1
 694:	a0 7f       	andi	r26, 0xF0	; 240
 696:	a0 3f       	cpi	r26, 0xF0	; 240
 698:	21 f4       	brne	.+8      	; 0x6a2 <__LOCK_REGION_LENGTH__+0x2a2>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 69a:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 69c:	46 2d       	mov	r20, r6
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 69e:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 6a0:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 3)	//4번째 숫자 단계
 6a2:	b3 30       	cpi	r27, 0x03	; 3
 6a4:	09 f4       	brne	.+2      	; 0x6a8 <__LOCK_REGION_LENGTH__+0x2a8>
 6a6:	61 cf       	rjmp	.-318    	; 0x56a <__LOCK_REGION_LENGTH__+0x16a>
 6a8:	6d 87       	std	Y+13, r22	; 0x0d
 6aa:	6e 2d       	mov	r22, r14
 6ac:	79 8b       	std	Y+17, r23	; 0x11
 6ae:	70 2f       	mov	r23, r16
 6b0:	fb 2e       	mov	r15, r27
 6b2:	58 8b       	std	Y+16, r21	; 0x10
 6b4:	5d 2d       	mov	r21, r13
 6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <__LOCK_REGION_LENGTH__+0x2c4>
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 6b8:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 6ba:	a1 2c       	mov	r10, r1
				state2 = 0;
				state3 = 0;
				state4 = 0;
 6bc:	21 2c       	mov	r2, r1
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렸을때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
 6be:	f9 2e       	mov	r15, r25
 6c0:	01 c0       	rjmp	.+2      	; 0x6c4 <__LOCK_REGION_LENGTH__+0x2c4>
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 3)	//4번째 숫자 단계
 6c2:	f9 2c       	mov	r15, r9
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 4)	//비밀번호 확인단계
 6c4:	b4 e0       	ldi	r27, 0x04	; 4
 6c6:	fb 16       	cp	r15, r27
 6c8:	21 f0       	breq	.+8      	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
 6ca:	8f c0       	rjmp	.+286    	; 0x7ea <__LOCK_REGION_LENGTH__+0x3ea>
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 6cc:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 4;	//비밀번호 확인단계로
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 6ce:	a1 2c       	mov	r10, r1
				state2 = 0;
				state3 = 0;
				state4 = 0;
 6d0:	21 2c       	mov	r2, r1

			}
			else  //비밀번호 일치하지 않을 때
			{
				PORTG = 0b00001000;
				PORTD = ~(0b00110111);	//NONO 표시
 6d2:	0f 2e       	mov	r0, r31
 6d4:	f8 ec       	ldi	r31, 0xC8	; 200
 6d6:	9f 2e       	mov	r9, r31
 6d8:	f0 2d       	mov	r31, r0
				_delay_ms(5);
				PORTG = 0b00000100;
				PORTD = ~(0b00111111);
 6da:	0f 2e       	mov	r0, r31
 6dc:	f0 ec       	ldi	r31, 0xC0	; 192
 6de:	df 2e       	mov	r13, r31
 6e0:	f0 2d       	mov	r31, r0
			{
				PORTG = 0b00001000;
				PORTD = ~(0b00111111);  //OPEN 표시
				_delay_ms(5);
				PORTG = 0b00000100;
				PORTD = ~(0b01110011);
 6e2:	0f 2e       	mov	r0, r31
 6e4:	fc e8       	ldi	r31, 0x8C	; 140
 6e6:	8f 2e       	mov	r8, r31
 6e8:	f0 2d       	mov	r31, r0
				_delay_ms(5);
				PORTG = 0b00000010;
				PORTD = ~(0b01111001);
 6ea:	e4 2e       	mov	r14, r20
 6ec:	fe 84       	ldd	r15, Y+14	; 0x0e
				state4 = 0;
			}
		}
		while(phase == 4)	//비밀번호 확인단계
		{
			if((number1 == save1) && (number2 == save2) && (number3 == save3) && (number4 == save4)) //비밀번호 일치할때
 6ee:	48 89       	ldd	r20, Y+16	; 0x10
 6f0:	54 13       	cpse	r21, r20
 6f2:	3f c0       	rjmp	.+126    	; 0x772 <__LOCK_REGION_LENGTH__+0x372>
 6f4:	ad 85       	ldd	r26, Y+13	; 0x0d
 6f6:	6a 13       	cpse	r22, r26
 6f8:	3c c0       	rjmp	.+120    	; 0x772 <__LOCK_REGION_LENGTH__+0x372>
 6fa:	7c 11       	cpse	r23, r12
 6fc:	3a c0       	rjmp	.+116    	; 0x772 <__LOCK_REGION_LENGTH__+0x372>
 6fe:	b9 89       	ldd	r27, Y+17	; 0x11
 700:	bb 11       	cpse	r27, r11
 702:	37 c0       	rjmp	.+110    	; 0x772 <__LOCK_REGION_LENGTH__+0x372>
			{
				PORTG = 0b00001000;
 704:	30 82       	st	Z, r3
				PORTD = ~(0b00111111);  //OPEN 표시
 706:	d2 ba       	out	0x12, r13	; 18
 708:	af e1       	ldi	r26, 0x1F	; 31
 70a:	be e4       	ldi	r27, 0x4E	; 78
 70c:	11 97       	sbiw	r26, 0x01	; 1
 70e:	f1 f7       	brne	.-4      	; 0x70c <__LOCK_REGION_LENGTH__+0x30c>
 710:	00 c0       	rjmp	.+0      	; 0x712 <__LOCK_REGION_LENGTH__+0x312>
 712:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000100;
 714:	90 83       	st	Z, r25
				PORTD = ~(0b01110011);
 716:	82 ba       	out	0x12, r8	; 18
 718:	af e1       	ldi	r26, 0x1F	; 31
 71a:	be e4       	ldi	r27, 0x4E	; 78
 71c:	11 97       	sbiw	r26, 0x01	; 1
 71e:	f1 f7       	brne	.-4      	; 0x71c <__LOCK_REGION_LENGTH__+0x31c>
 720:	00 c0       	rjmp	.+0      	; 0x722 <__LOCK_REGION_LENGTH__+0x322>
 722:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000010;
 724:	20 83       	st	Z, r18
				PORTD = ~(0b01111001);
 726:	b6 e8       	ldi	r27, 0x86	; 134
 728:	b2 bb       	out	0x12, r27	; 18
 72a:	af e1       	ldi	r26, 0x1F	; 31
 72c:	be e4       	ldi	r27, 0x4E	; 78
 72e:	11 97       	sbiw	r26, 0x01	; 1
 730:	f1 f7       	brne	.-4      	; 0x72e <__LOCK_REGION_LENGTH__+0x32e>
 732:	00 c0       	rjmp	.+0      	; 0x734 <__LOCK_REGION_LENGTH__+0x334>
 734:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000001;
 736:	80 83       	st	Z, r24
				PORTD = ~(0b00110111);
 738:	92 ba       	out	0x12, r9	; 18
 73a:	af e1       	ldi	r26, 0x1F	; 31
 73c:	be e4       	ldi	r27, 0x4E	; 78
 73e:	11 97       	sbiw	r26, 0x01	; 1
 740:	f1 f7       	brne	.-4      	; 0x73e <__LOCK_REGION_LENGTH__+0x33e>
 742:	00 c0       	rjmp	.+0      	; 0x744 <__LOCK_REGION_LENGTH__+0x344>
 744:	00 00       	nop
				_delay_ms(5);
				if(((PINE & 0xF0) == 0b11100000) && (state4 == 0))	//비밀번호 일치하는 상황에서 4번째 스위치 눌렀을때
 746:	41 b1       	in	r20, 0x01	; 1
 748:	40 7f       	andi	r20, 0xF0	; 240
 74a:	40 3e       	cpi	r20, 0xE0	; 224
 74c:	59 f4       	brne	.+22     	; 0x764 <__LOCK_REGION_LENGTH__+0x364>
 74e:	21 10       	cpse	r2, r1
 750:	09 c0       	rjmp	.+18     	; 0x764 <__LOCK_REGION_LENGTH__+0x364>
 752:	af e3       	ldi	r26, 0x3F	; 63
 754:	bc e9       	ldi	r27, 0x9C	; 156
 756:	11 97       	sbiw	r26, 0x01	; 1
 758:	f1 f7       	brne	.-4      	; 0x756 <__LOCK_REGION_LENGTH__+0x356>
 75a:	00 c0       	rjmp	.+0      	; 0x75c <__LOCK_REGION_LENGTH__+0x35c>
 75c:	00 00       	nop
				{
					_delay_ms(10);
					state4 = 1;
 75e:	2c 84       	ldd	r2, Y+12	; 0x0c
					phase = 5;	//비밀번호 변경 단계로 이동
 760:	45 e0       	ldi	r20, 0x05	; 5
 762:	2a c0       	rjmp	.+84     	; 0x7b8 <__LOCK_REGION_LENGTH__+0x3b8>
				}
				else if((PINE & 0xF0) == 0xF0)
 764:	41 b1       	in	r20, 0x01	; 1
 766:	40 7f       	andi	r20, 0xF0	; 240
 768:	40 3f       	cpi	r20, 0xF0	; 240
 76a:	29 f5       	brne	.+74     	; 0x7b6 <__LOCK_REGION_LENGTH__+0x3b6>
				{
					state4 = 0;
 76c:	26 2c       	mov	r2, r6
				{
					_delay_ms(10);
					state4 = 1;
					phase = 5;	//비밀번호 변경 단계로 이동
				}
				else if((PINE & 0xF0) == 0xF0)
 76e:	4f 2d       	mov	r20, r15
 770:	23 c0       	rjmp	.+70     	; 0x7b8 <__LOCK_REGION_LENGTH__+0x3b8>
				}

			}
			else  //비밀번호 일치하지 않을 때
			{
				PORTG = 0b00001000;
 772:	30 82       	st	Z, r3
				PORTD = ~(0b00110111);	//NONO 표시
 774:	92 ba       	out	0x12, r9	; 18
 776:	af e1       	ldi	r26, 0x1F	; 31
 778:	be e4       	ldi	r27, 0x4E	; 78
 77a:	11 97       	sbiw	r26, 0x01	; 1
 77c:	f1 f7       	brne	.-4      	; 0x77a <__LOCK_REGION_LENGTH__+0x37a>
 77e:	00 c0       	rjmp	.+0      	; 0x780 <__LOCK_REGION_LENGTH__+0x380>
 780:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000100;
 782:	90 83       	st	Z, r25
				PORTD = ~(0b00111111);
 784:	d2 ba       	out	0x12, r13	; 18
 786:	af e1       	ldi	r26, 0x1F	; 31
 788:	be e4       	ldi	r27, 0x4E	; 78
 78a:	11 97       	sbiw	r26, 0x01	; 1
 78c:	f1 f7       	brne	.-4      	; 0x78a <__LOCK_REGION_LENGTH__+0x38a>
 78e:	00 c0       	rjmp	.+0      	; 0x790 <__LOCK_REGION_LENGTH__+0x390>
 790:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000010;
 792:	20 83       	st	Z, r18
				PORTD = ~(0b00110111);
 794:	92 ba       	out	0x12, r9	; 18
 796:	af e1       	ldi	r26, 0x1F	; 31
 798:	be e4       	ldi	r27, 0x4E	; 78
 79a:	11 97       	sbiw	r26, 0x01	; 1
 79c:	f1 f7       	brne	.-4      	; 0x79a <__LOCK_REGION_LENGTH__+0x39a>
 79e:	00 c0       	rjmp	.+0      	; 0x7a0 <__LOCK_REGION_LENGTH__+0x3a0>
 7a0:	00 00       	nop
				_delay_ms(5);
				PORTG = 0b00000001;
 7a2:	80 83       	st	Z, r24
				PORTD = ~(0b00111111);
 7a4:	d2 ba       	out	0x12, r13	; 18
 7a6:	af e1       	ldi	r26, 0x1F	; 31
 7a8:	be e4       	ldi	r27, 0x4E	; 78
 7aa:	11 97       	sbiw	r26, 0x01	; 1
 7ac:	f1 f7       	brne	.-4      	; 0x7aa <__LOCK_REGION_LENGTH__+0x3aa>
 7ae:	00 c0       	rjmp	.+0      	; 0x7b0 <__LOCK_REGION_LENGTH__+0x3b0>
 7b0:	00 00       	nop
 7b2:	4f 2d       	mov	r20, r15
 7b4:	01 c0       	rjmp	.+2      	; 0x7b8 <__LOCK_REGION_LENGTH__+0x3b8>
 7b6:	4f 2d       	mov	r20, r15
				_delay_ms(5);

			}

			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 눌렀을 때 다시 비밀번호 입력 단계로
 7b8:	01 b1       	in	r16, 0x01	; 1
 7ba:	00 7f       	andi	r16, 0xF0	; 240
 7bc:	00 3d       	cpi	r16, 0xD0	; 208
 7be:	59 f4       	brne	.+22     	; 0x7d6 <__LOCK_REGION_LENGTH__+0x3d6>
 7c0:	e1 10       	cpse	r14, r1
 7c2:	09 c0       	rjmp	.+18     	; 0x7d6 <__LOCK_REGION_LENGTH__+0x3d6>
 7c4:	af e3       	ldi	r26, 0x3F	; 63
 7c6:	bc e9       	ldi	r27, 0x9C	; 156
 7c8:	11 97       	sbiw	r26, 0x01	; 1
 7ca:	f1 f7       	brne	.-4      	; 0x7c8 <__LOCK_REGION_LENGTH__+0x3c8>
 7cc:	00 c0       	rjmp	.+0      	; 0x7ce <__LOCK_REGION_LENGTH__+0x3ce>
 7ce:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
 7d0:	48 2f       	mov	r20, r24
				phase = 0;
 7d2:	d1 2c       	mov	r13, r1
 7d4:	c8 c0       	rjmp	.+400    	; 0x966 <__LOCK_REGION_LENGTH__+0x566>
			}
			else if((PINE & 0xF0) == 0xF0)
 7d6:	01 b1       	in	r16, 0x01	; 1
 7d8:	00 7f       	andi	r16, 0xF0	; 240
 7da:	00 3f       	cpi	r16, 0xF0	; 240
 7dc:	09 f4       	brne	.+2      	; 0x7e0 <__LOCK_REGION_LENGTH__+0x3e0>
			{
				state3 = 0;
 7de:	e6 2c       	mov	r14, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 4)	//비밀번호 확인단계
 7e0:	44 30       	cpi	r20, 0x04	; 4
 7e2:	09 f4       	brne	.+2      	; 0x7e6 <__LOCK_REGION_LENGTH__+0x3e6>
 7e4:	84 cf       	rjmp	.-248    	; 0x6ee <__LOCK_REGION_LENGTH__+0x2ee>
 7e6:	f4 2e       	mov	r15, r20
 7e8:	4e 2d       	mov	r20, r14
			else if((PINE & 0xF0) == 0xF0)
			{
				state3 = 0;
			}
		}
		while(phase == 5)	//비밀번호 변경 단계 첫번째 숫자 수정
 7ea:	b5 e0       	ldi	r27, 0x05	; 5
 7ec:	fb 12       	cpse	r15, r27
 7ee:	ba c0       	rjmp	.+372    	; 0x964 <__LOCK_REGION_LENGTH__+0x564>
 7f0:	9f 2c       	mov	r9, r15
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//두번째 스위치 누를 때
			{
				_delay_ms(10);
				state2 = 1;
				phase = 6;	//다음 비밀번호로 이동
 7f2:	0f 2e       	mov	r0, r31
 7f4:	f6 e0       	ldi	r31, 0x06	; 6
 7f6:	8f 2e       	mov	r8, r31
 7f8:	f0 2d       	mov	r31, r0
 7fa:	f8 88       	ldd	r15, Y+16	; 0x10
 7fc:	09 89       	ldd	r16, Y+17	; 0x11
				state3 = 0;
			}
		}
		while(phase == 5)	//비밀번호 변경 단계 첫번째 숫자 수정
		{
			PORTG = 0b00001000;
 7fe:	30 83       	st	Z, r19
			PORTD = ~segment3[save1];	//비밀번호 숫자 표시
 800:	a1 e0       	ldi	r26, 0x01	; 1
 802:	b0 e0       	ldi	r27, 0x00	; 0
 804:	ac 0f       	add	r26, r28
 806:	bd 1f       	adc	r27, r29
 808:	a5 0f       	add	r26, r21
 80a:	b1 1d       	adc	r27, r1
 80c:	ac 91       	ld	r26, X
 80e:	a0 95       	com	r26
 810:	a2 bb       	out	0x12, r26	; 18
 812:	af e1       	ldi	r26, 0x1F	; 31
 814:	be e4       	ldi	r27, 0x4E	; 78
 816:	11 97       	sbiw	r26, 0x01	; 1
 818:	f1 f7       	brne	.-4      	; 0x816 <__LOCK_REGION_LENGTH__+0x416>
 81a:	00 c0       	rjmp	.+0      	; 0x81c <__LOCK_REGION_LENGTH__+0x41c>
 81c:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 81e:	90 83       	st	Z, r25
			PORTD = ~segment3[save2];
 820:	a1 e0       	ldi	r26, 0x01	; 1
 822:	b0 e0       	ldi	r27, 0x00	; 0
 824:	ac 0f       	add	r26, r28
 826:	bd 1f       	adc	r27, r29
 828:	a6 0f       	add	r26, r22
 82a:	b1 1d       	adc	r27, r1
 82c:	ac 91       	ld	r26, X
 82e:	a0 95       	com	r26
 830:	a2 bb       	out	0x12, r26	; 18
 832:	af e1       	ldi	r26, 0x1F	; 31
 834:	be e4       	ldi	r27, 0x4E	; 78
 836:	11 97       	sbiw	r26, 0x01	; 1
 838:	f1 f7       	brne	.-4      	; 0x836 <__LOCK_REGION_LENGTH__+0x436>
 83a:	00 c0       	rjmp	.+0      	; 0x83c <__LOCK_REGION_LENGTH__+0x43c>
 83c:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 83e:	ab 85       	ldd	r26, Y+11	; 0x0b
 840:	a0 95       	com	r26
 842:	a2 bb       	out	0x12, r26	; 18
 844:	af e1       	ldi	r26, 0x1F	; 31
 846:	be e4       	ldi	r27, 0x4E	; 78
 848:	11 97       	sbiw	r26, 0x01	; 1
 84a:	f1 f7       	brne	.-4      	; 0x848 <__LOCK_REGION_LENGTH__+0x448>
 84c:	00 c0       	rjmp	.+0      	; 0x84e <__LOCK_REGION_LENGTH__+0x44e>
 84e:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 850:	20 83       	st	Z, r18
			PORTD = ~segment3[save3];
 852:	a1 e0       	ldi	r26, 0x01	; 1
 854:	b0 e0       	ldi	r27, 0x00	; 0
 856:	ac 0f       	add	r26, r28
 858:	bd 1f       	adc	r27, r29
 85a:	a7 0f       	add	r26, r23
 85c:	b1 1d       	adc	r27, r1
 85e:	ac 91       	ld	r26, X
 860:	a0 95       	com	r26
 862:	a2 bb       	out	0x12, r26	; 18
 864:	af e1       	ldi	r26, 0x1F	; 31
 866:	be e4       	ldi	r27, 0x4E	; 78
 868:	11 97       	sbiw	r26, 0x01	; 1
 86a:	f1 f7       	brne	.-4      	; 0x868 <__LOCK_REGION_LENGTH__+0x468>
 86c:	00 c0       	rjmp	.+0      	; 0x86e <__LOCK_REGION_LENGTH__+0x46e>
 86e:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 870:	ab 85       	ldd	r26, Y+11	; 0x0b
 872:	a0 95       	com	r26
 874:	a2 bb       	out	0x12, r26	; 18
 876:	af e1       	ldi	r26, 0x1F	; 31
 878:	be e4       	ldi	r27, 0x4E	; 78
 87a:	11 97       	sbiw	r26, 0x01	; 1
 87c:	f1 f7       	brne	.-4      	; 0x87a <__LOCK_REGION_LENGTH__+0x47a>
 87e:	00 c0       	rjmp	.+0      	; 0x880 <__LOCK_REGION_LENGTH__+0x480>
 880:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 882:	80 83       	st	Z, r24
			PORTD = ~segment3[save4];
 884:	a1 e0       	ldi	r26, 0x01	; 1
 886:	b0 e0       	ldi	r27, 0x00	; 0
 888:	ac 0f       	add	r26, r28
 88a:	bd 1f       	adc	r27, r29
 88c:	a0 0f       	add	r26, r16
 88e:	b1 1d       	adc	r27, r1
 890:	ac 91       	ld	r26, X
 892:	a0 95       	com	r26
 894:	a2 bb       	out	0x12, r26	; 18
 896:	af e1       	ldi	r26, 0x1F	; 31
 898:	be e4       	ldi	r27, 0x4E	; 78
 89a:	11 97       	sbiw	r26, 0x01	; 1
 89c:	f1 f7       	brne	.-4      	; 0x89a <__LOCK_REGION_LENGTH__+0x49a>
 89e:	00 c0       	rjmp	.+0      	; 0x8a0 <__LOCK_REGION_LENGTH__+0x4a0>
 8a0:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 8a2:	ab 85       	ldd	r26, Y+11	; 0x0b
 8a4:	a0 95       	com	r26
 8a6:	a2 bb       	out	0x12, r26	; 18
 8a8:	af e1       	ldi	r26, 0x1F	; 31
 8aa:	be e4       	ldi	r27, 0x4E	; 78
 8ac:	11 97       	sbiw	r26, 0x01	; 1
 8ae:	f1 f7       	brne	.-4      	; 0x8ac <__LOCK_REGION_LENGTH__+0x4ac>
 8b0:	00 c0       	rjmp	.+0      	; 0x8b2 <__LOCK_REGION_LENGTH__+0x4b2>
 8b2:	00 00       	nop
			_delay_ms(5);




			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
 8b4:	a1 b1       	in	r26, 0x01	; 1
 8b6:	a0 7f       	andi	r26, 0xF0	; 240
 8b8:	a0 37       	cpi	r26, 0x70	; 112
 8ba:	c1 f4       	brne	.+48     	; 0x8ec <__LOCK_REGION_LENGTH__+0x4ec>
 8bc:	a1 10       	cpse	r10, r1
 8be:	16 c0       	rjmp	.+44     	; 0x8ec <__LOCK_REGION_LENGTH__+0x4ec>
 8c0:	af e3       	ldi	r26, 0x3F	; 63
 8c2:	bc e9       	ldi	r27, 0x9C	; 156
 8c4:	11 97       	sbiw	r26, 0x01	; 1
 8c6:	f1 f7       	brne	.-4      	; 0x8c4 <__LOCK_REGION_LENGTH__+0x4c4>
 8c8:	00 c0       	rjmp	.+0      	; 0x8ca <__LOCK_REGION_LENGTH__+0x4ca>
 8ca:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				save1++;	//첫번째 비밀번호 증가
 8cc:	5f 5f       	subi	r21, 0xFF	; 255
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
 8ce:	5a 30       	cpi	r21, 0x0A	; 10
 8d0:	09 f4       	brne	.+2      	; 0x8d4 <__LOCK_REGION_LENGTH__+0x4d4>
 8d2:	50 e0       	ldi	r21, 0x00	; 0
				if(save2 == 10) save2 = 0;
 8d4:	6a 30       	cpi	r22, 0x0A	; 10
 8d6:	09 f4       	brne	.+2      	; 0x8da <__LOCK_REGION_LENGTH__+0x4da>
 8d8:	60 e0       	ldi	r22, 0x00	; 0
				if(save3 == 10) save3 = 0;
 8da:	7a 30       	cpi	r23, 0x0A	; 10
 8dc:	09 f4       	brne	.+2      	; 0x8e0 <__LOCK_REGION_LENGTH__+0x4e0>
 8de:	70 e0       	ldi	r23, 0x00	; 0
				if(save4 == 10) save4 = 0;
 8e0:	0a 30       	cpi	r16, 0x0A	; 10
 8e2:	19 f4       	brne	.+6      	; 0x8ea <__LOCK_REGION_LENGTH__+0x4ea>
 8e4:	00 e0       	ldi	r16, 0x00	; 0


			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
			{
				_delay_ms(10);
				state1 = 1;
 8e6:	ac 84       	ldd	r10, Y+12	; 0x0c
 8e8:	01 c0       	rjmp	.+2      	; 0x8ec <__LOCK_REGION_LENGTH__+0x4ec>
 8ea:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
				if(save2 == 10) save2 = 0;
				if(save3 == 10) save3 = 0;
				if(save4 == 10) save4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//두번째 스위치 누를 때
 8ec:	a1 b1       	in	r26, 0x01	; 1
 8ee:	a0 7f       	andi	r26, 0xF0	; 240
 8f0:	a0 3b       	cpi	r26, 0xB0	; 176
 8f2:	59 f4       	brne	.+22     	; 0x90a <__LOCK_REGION_LENGTH__+0x50a>
 8f4:	71 10       	cpse	r7, r1
 8f6:	0b c0       	rjmp	.+22     	; 0x90e <__LOCK_REGION_LENGTH__+0x50e>
 8f8:	af e3       	ldi	r26, 0x3F	; 63
 8fa:	bc e9       	ldi	r27, 0x9C	; 156
 8fc:	11 97       	sbiw	r26, 0x01	; 1
 8fe:	f1 f7       	brne	.-4      	; 0x8fc <__LOCK_REGION_LENGTH__+0x4fc>
 900:	00 c0       	rjmp	.+0      	; 0x902 <__LOCK_REGION_LENGTH__+0x502>
 902:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 904:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 6;	//다음 비밀번호로 이동
 906:	b8 2d       	mov	r27, r8
 908:	03 c0       	rjmp	.+6      	; 0x910 <__LOCK_REGION_LENGTH__+0x510>
 90a:	b9 2d       	mov	r27, r9
 90c:	01 c0       	rjmp	.+2      	; 0x910 <__LOCK_REGION_LENGTH__+0x510>
 90e:	b9 2d       	mov	r27, r9
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
 910:	a1 b1       	in	r26, 0x01	; 1
 912:	a0 7f       	andi	r26, 0xF0	; 240
 914:	a0 3d       	cpi	r26, 0xD0	; 208
 916:	b9 f4       	brne	.+46     	; 0x946 <__LOCK_REGION_LENGTH__+0x546>
 918:	41 11       	cpse	r20, r1
 91a:	15 c0       	rjmp	.+42     	; 0x946 <__LOCK_REGION_LENGTH__+0x546>
 91c:	f8 8a       	std	Y+16, r15	; 0x10
 91e:	09 8b       	std	Y+17, r16	; 0x11
 920:	af e3       	ldi	r26, 0x3F	; 63
 922:	bc e9       	ldi	r27, 0x9C	; 156
 924:	11 97       	sbiw	r26, 0x01	; 1
 926:	f1 f7       	brne	.-4      	; 0x924 <__LOCK_REGION_LENGTH__+0x524>
 928:	00 c0       	rjmp	.+0      	; 0x92a <__LOCK_REGION_LENGTH__+0x52a>
 92a:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 92c:	f1 b0       	in	r15, 0x01	; 1
 92e:	bf 2d       	mov	r27, r15
 930:	b0 7f       	andi	r27, 0xF0	; 240
 932:	a0 ef       	ldi	r26, 0xF0	; 240
 934:	ba 17       	cp	r27, r26
 936:	09 f4       	brne	.+2      	; 0x93a <__LOCK_REGION_LENGTH__+0x53a>
 938:	ce c0       	rjmp	.+412    	; 0xad6 <__LOCK_REGION_LENGTH__+0x6d6>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 93a:	0f 2e       	mov	r0, r31
 93c:	f9 e0       	ldi	r31, 0x09	; 9
 93e:	df 2e       	mov	r13, r31
 940:	f0 2d       	mov	r31, r0
				phase = 6;	//다음 비밀번호로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
 942:	48 2f       	mov	r20, r24
 944:	10 c0       	rjmp	.+32     	; 0x966 <__LOCK_REGION_LENGTH__+0x566>
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 946:	a1 b1       	in	r26, 0x01	; 1
 948:	a0 7f       	andi	r26, 0xF0	; 240
 94a:	a0 3f       	cpi	r26, 0xF0	; 240
 94c:	21 f4       	brne	.+8      	; 0x956 <__LOCK_REGION_LENGTH__+0x556>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 94e:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 950:	46 2d       	mov	r20, r6
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 952:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 954:	a6 2c       	mov	r10, r6
			else if((PINE & 0xF0) == 0xF0)
			{
				state3 = 0;
			}
		}
		while(phase == 5)	//비밀번호 변경 단계 첫번째 숫자 수정
 956:	b5 30       	cpi	r27, 0x05	; 5
 958:	09 f4       	brne	.+2      	; 0x95c <__LOCK_REGION_LENGTH__+0x55c>
 95a:	51 cf       	rjmp	.-350    	; 0x7fe <__LOCK_REGION_LENGTH__+0x3fe>
 95c:	09 8b       	std	Y+17, r16	; 0x11
 95e:	db 2e       	mov	r13, r27
 960:	f8 8a       	std	Y+16, r15	; 0x10
 962:	01 c0       	rjmp	.+2      	; 0x966 <__LOCK_REGION_LENGTH__+0x566>
 964:	df 2c       	mov	r13, r15
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 6)	//비밀번호 2번째 숫자 변경
 966:	b6 e0       	ldi	r27, 0x06	; 6
 968:	db 12       	cpse	r13, r27
 96a:	bd c0       	rjmp	.+378    	; 0xae6 <__LOCK_REGION_LENGTH__+0x6e6>
 96c:	f8 88       	ldd	r15, Y+16	; 0x10
 96e:	09 89       	ldd	r16, Y+17	; 0x11
		{
			PORTG = 0b00001000;
 970:	30 83       	st	Z, r19
			PORTD = ~segment3[save1];
 972:	a1 e0       	ldi	r26, 0x01	; 1
 974:	b0 e0       	ldi	r27, 0x00	; 0
 976:	ac 0f       	add	r26, r28
 978:	bd 1f       	adc	r27, r29
 97a:	a5 0f       	add	r26, r21
 97c:	b1 1d       	adc	r27, r1
 97e:	ac 91       	ld	r26, X
 980:	a0 95       	com	r26
 982:	a2 bb       	out	0x12, r26	; 18
 984:	af e1       	ldi	r26, 0x1F	; 31
 986:	be e4       	ldi	r27, 0x4E	; 78
 988:	11 97       	sbiw	r26, 0x01	; 1
 98a:	f1 f7       	brne	.-4      	; 0x988 <__LOCK_REGION_LENGTH__+0x588>
 98c:	00 c0       	rjmp	.+0      	; 0x98e <__LOCK_REGION_LENGTH__+0x58e>
 98e:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 990:	ab 85       	ldd	r26, Y+11	; 0x0b
 992:	a0 95       	com	r26
 994:	a2 bb       	out	0x12, r26	; 18
 996:	af e1       	ldi	r26, 0x1F	; 31
 998:	be e4       	ldi	r27, 0x4E	; 78
 99a:	11 97       	sbiw	r26, 0x01	; 1
 99c:	f1 f7       	brne	.-4      	; 0x99a <__LOCK_REGION_LENGTH__+0x59a>
 99e:	00 c0       	rjmp	.+0      	; 0x9a0 <__LOCK_REGION_LENGTH__+0x5a0>
 9a0:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 9a2:	90 83       	st	Z, r25
			PORTD = ~segment3[save2];
 9a4:	a1 e0       	ldi	r26, 0x01	; 1
 9a6:	b0 e0       	ldi	r27, 0x00	; 0
 9a8:	ac 0f       	add	r26, r28
 9aa:	bd 1f       	adc	r27, r29
 9ac:	a6 0f       	add	r26, r22
 9ae:	b1 1d       	adc	r27, r1
 9b0:	ac 91       	ld	r26, X
 9b2:	a0 95       	com	r26
 9b4:	a2 bb       	out	0x12, r26	; 18
 9b6:	af e1       	ldi	r26, 0x1F	; 31
 9b8:	be e4       	ldi	r27, 0x4E	; 78
 9ba:	11 97       	sbiw	r26, 0x01	; 1
 9bc:	f1 f7       	brne	.-4      	; 0x9ba <__LOCK_REGION_LENGTH__+0x5ba>
 9be:	00 c0       	rjmp	.+0      	; 0x9c0 <__LOCK_REGION_LENGTH__+0x5c0>
 9c0:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 9c2:	20 83       	st	Z, r18
			PORTD = ~segment3[save3];
 9c4:	a1 e0       	ldi	r26, 0x01	; 1
 9c6:	b0 e0       	ldi	r27, 0x00	; 0
 9c8:	ac 0f       	add	r26, r28
 9ca:	bd 1f       	adc	r27, r29
 9cc:	a7 0f       	add	r26, r23
 9ce:	b1 1d       	adc	r27, r1
 9d0:	ac 91       	ld	r26, X
 9d2:	a0 95       	com	r26
 9d4:	a2 bb       	out	0x12, r26	; 18
 9d6:	af e1       	ldi	r26, 0x1F	; 31
 9d8:	be e4       	ldi	r27, 0x4E	; 78
 9da:	11 97       	sbiw	r26, 0x01	; 1
 9dc:	f1 f7       	brne	.-4      	; 0x9da <__LOCK_REGION_LENGTH__+0x5da>
 9de:	00 c0       	rjmp	.+0      	; 0x9e0 <__LOCK_REGION_LENGTH__+0x5e0>
 9e0:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 9e2:	ab 85       	ldd	r26, Y+11	; 0x0b
 9e4:	a0 95       	com	r26
 9e6:	a2 bb       	out	0x12, r26	; 18
 9e8:	af e1       	ldi	r26, 0x1F	; 31
 9ea:	be e4       	ldi	r27, 0x4E	; 78
 9ec:	11 97       	sbiw	r26, 0x01	; 1
 9ee:	f1 f7       	brne	.-4      	; 0x9ec <__LOCK_REGION_LENGTH__+0x5ec>
 9f0:	00 c0       	rjmp	.+0      	; 0x9f2 <__LOCK_REGION_LENGTH__+0x5f2>
 9f2:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 9f4:	80 83       	st	Z, r24
			PORTD = ~segment3[save4];
 9f6:	a1 e0       	ldi	r26, 0x01	; 1
 9f8:	b0 e0       	ldi	r27, 0x00	; 0
 9fa:	ac 0f       	add	r26, r28
 9fc:	bd 1f       	adc	r27, r29
 9fe:	a0 0f       	add	r26, r16
 a00:	b1 1d       	adc	r27, r1
 a02:	ac 91       	ld	r26, X
 a04:	a0 95       	com	r26
 a06:	a2 bb       	out	0x12, r26	; 18
 a08:	af e1       	ldi	r26, 0x1F	; 31
 a0a:	be e4       	ldi	r27, 0x4E	; 78
 a0c:	11 97       	sbiw	r26, 0x01	; 1
 a0e:	f1 f7       	brne	.-4      	; 0xa0c <__LOCK_REGION_LENGTH__+0x60c>
 a10:	00 c0       	rjmp	.+0      	; 0xa12 <__LOCK_REGION_LENGTH__+0x612>
 a12:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 a14:	ab 85       	ldd	r26, Y+11	; 0x0b
 a16:	a0 95       	com	r26
 a18:	a2 bb       	out	0x12, r26	; 18
 a1a:	af e1       	ldi	r26, 0x1F	; 31
 a1c:	be e4       	ldi	r27, 0x4E	; 78
 a1e:	11 97       	sbiw	r26, 0x01	; 1
 a20:	f1 f7       	brne	.-4      	; 0xa1e <__LOCK_REGION_LENGTH__+0x61e>
 a22:	00 c0       	rjmp	.+0      	; 0xa24 <__LOCK_REGION_LENGTH__+0x624>
 a24:	00 00       	nop
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
 a26:	a1 b1       	in	r26, 0x01	; 1
 a28:	a0 7f       	andi	r26, 0xF0	; 240
 a2a:	a0 37       	cpi	r26, 0x70	; 112
 a2c:	c1 f4       	brne	.+48     	; 0xa5e <__LOCK_REGION_LENGTH__+0x65e>
 a2e:	a1 10       	cpse	r10, r1
 a30:	16 c0       	rjmp	.+44     	; 0xa5e <__LOCK_REGION_LENGTH__+0x65e>
 a32:	af e3       	ldi	r26, 0x3F	; 63
 a34:	bc e9       	ldi	r27, 0x9C	; 156
 a36:	11 97       	sbiw	r26, 0x01	; 1
 a38:	f1 f7       	brne	.-4      	; 0xa36 <__LOCK_REGION_LENGTH__+0x636>
 a3a:	00 c0       	rjmp	.+0      	; 0xa3c <__LOCK_REGION_LENGTH__+0x63c>
 a3c:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				save2++;	//두번째 비밀번호 증가
 a3e:	6f 5f       	subi	r22, 0xFF	; 255
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
 a40:	5a 30       	cpi	r21, 0x0A	; 10
 a42:	09 f4       	brne	.+2      	; 0xa46 <__LOCK_REGION_LENGTH__+0x646>
 a44:	50 e0       	ldi	r21, 0x00	; 0
				if(save2 == 10) save2 = 0;
 a46:	6a 30       	cpi	r22, 0x0A	; 10
 a48:	09 f4       	brne	.+2      	; 0xa4c <__LOCK_REGION_LENGTH__+0x64c>
 a4a:	60 e0       	ldi	r22, 0x00	; 0
				if(save3 == 10) save3 = 0;
 a4c:	7a 30       	cpi	r23, 0x0A	; 10
 a4e:	09 f4       	brne	.+2      	; 0xa52 <__LOCK_REGION_LENGTH__+0x652>
 a50:	70 e0       	ldi	r23, 0x00	; 0
				if(save4 == 10) save4 = 0;
 a52:	0a 30       	cpi	r16, 0x0A	; 10
 a54:	19 f4       	brne	.+6      	; 0xa5c <__LOCK_REGION_LENGTH__+0x65c>
 a56:	00 e0       	ldi	r16, 0x00	; 0
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
			{
				_delay_ms(10);
				state1 = 1;
 a58:	ac 84       	ldd	r10, Y+12	; 0x0c
 a5a:	01 c0       	rjmp	.+2      	; 0xa5e <__LOCK_REGION_LENGTH__+0x65e>
 a5c:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
				if(save2 == 10) save2 = 0;
				if(save3 == 10) save3 = 0;
				if(save4 == 10) save4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//두번째 스위치 누를 때
 a5e:	a1 b1       	in	r26, 0x01	; 1
 a60:	a0 7f       	andi	r26, 0xF0	; 240
 a62:	a0 3b       	cpi	r26, 0xB0	; 176
 a64:	59 f4       	brne	.+22     	; 0xa7c <__LOCK_REGION_LENGTH__+0x67c>
 a66:	71 10       	cpse	r7, r1
 a68:	0b c0       	rjmp	.+22     	; 0xa80 <__LOCK_REGION_LENGTH__+0x680>
 a6a:	af e3       	ldi	r26, 0x3F	; 63
 a6c:	bc e9       	ldi	r27, 0x9C	; 156
 a6e:	11 97       	sbiw	r26, 0x01	; 1
 a70:	f1 f7       	brne	.-4      	; 0xa6e <__LOCK_REGION_LENGTH__+0x66e>
 a72:	00 c0       	rjmp	.+0      	; 0xa74 <__LOCK_REGION_LENGTH__+0x674>
 a74:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 a76:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 7;	//다음 비밀번호로 이동
 a78:	b7 e0       	ldi	r27, 0x07	; 7
 a7a:	03 c0       	rjmp	.+6      	; 0xa82 <__LOCK_REGION_LENGTH__+0x682>
 a7c:	bd 2d       	mov	r27, r13
 a7e:	01 c0       	rjmp	.+2      	; 0xa82 <__LOCK_REGION_LENGTH__+0x682>
 a80:	bd 2d       	mov	r27, r13
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
 a82:	a1 b1       	in	r26, 0x01	; 1
 a84:	a0 7f       	andi	r26, 0xF0	; 240
 a86:	a0 3d       	cpi	r26, 0xD0	; 208
 a88:	b9 f4       	brne	.+46     	; 0xab8 <__LOCK_REGION_LENGTH__+0x6b8>
 a8a:	41 11       	cpse	r20, r1
 a8c:	15 c0       	rjmp	.+42     	; 0xab8 <__LOCK_REGION_LENGTH__+0x6b8>
 a8e:	f8 8a       	std	Y+16, r15	; 0x10
 a90:	09 8b       	std	Y+17, r16	; 0x11
 a92:	af e3       	ldi	r26, 0x3F	; 63
 a94:	bc e9       	ldi	r27, 0x9C	; 156
 a96:	11 97       	sbiw	r26, 0x01	; 1
 a98:	f1 f7       	brne	.-4      	; 0xa96 <__LOCK_REGION_LENGTH__+0x696>
 a9a:	00 c0       	rjmp	.+0      	; 0xa9c <__LOCK_REGION_LENGTH__+0x69c>
 a9c:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 a9e:	f1 b0       	in	r15, 0x01	; 1
 aa0:	bf 2d       	mov	r27, r15
 aa2:	b0 7f       	andi	r27, 0xF0	; 240
 aa4:	a0 ef       	ldi	r26, 0xF0	; 240
 aa6:	ba 17       	cp	r27, r26
 aa8:	09 f4       	brne	.+2      	; 0xaac <__LOCK_REGION_LENGTH__+0x6ac>
 aaa:	d6 c0       	rjmp	.+428    	; 0xc58 <__LOCK_REGION_LENGTH__+0x858>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 aac:	0f 2e       	mov	r0, r31
 aae:	f9 e0       	ldi	r31, 0x09	; 9
 ab0:	8f 2e       	mov	r8, r31
 ab2:	f0 2d       	mov	r31, r0
				phase = 7;	//다음 비밀번호로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
 ab4:	48 2f       	mov	r20, r24
 ab6:	18 c0       	rjmp	.+48     	; 0xae8 <__LOCK_REGION_LENGTH__+0x6e8>
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 ab8:	a1 b1       	in	r26, 0x01	; 1
 aba:	a0 7f       	andi	r26, 0xF0	; 240
 abc:	a0 3f       	cpi	r26, 0xF0	; 240
 abe:	21 f4       	brne	.+8      	; 0xac8 <__LOCK_REGION_LENGTH__+0x6c8>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 ac0:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 ac2:	46 2d       	mov	r20, r6
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 ac4:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 ac6:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 6)	//비밀번호 2번째 숫자 변경
 ac8:	b6 30       	cpi	r27, 0x06	; 6
 aca:	09 f4       	brne	.+2      	; 0xace <__LOCK_REGION_LENGTH__+0x6ce>
 acc:	51 cf       	rjmp	.-350    	; 0x970 <__LOCK_REGION_LENGTH__+0x570>
 ace:	09 8b       	std	Y+17, r16	; 0x11
 ad0:	8b 2e       	mov	r8, r27
 ad2:	f8 8a       	std	Y+16, r15	; 0x10
 ad4:	09 c0       	rjmp	.+18     	; 0xae8 <__LOCK_REGION_LENGTH__+0x6e8>
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 ad6:	21 2c       	mov	r2, r1
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 ad8:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 ada:	a1 2c       	mov	r10, r1
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 adc:	0f 2e       	mov	r0, r31
 ade:	f9 e0       	ldi	r31, 0x09	; 9
 ae0:	8f 2e       	mov	r8, r31
 ae2:	f0 2d       	mov	r31, r0
 ae4:	01 c0       	rjmp	.+2      	; 0xae8 <__LOCK_REGION_LENGTH__+0x6e8>
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 6)	//비밀번호 2번째 숫자 변경
 ae6:	8d 2c       	mov	r8, r13
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 7)	//비밀번호 3번째 숫자 변경
 ae8:	b7 e0       	ldi	r27, 0x07	; 7
 aea:	8b 12       	cpse	r8, r27
 aec:	bd c0       	rjmp	.+378    	; 0xc68 <__LOCK_REGION_LENGTH__+0x868>
 aee:	f8 88       	ldd	r15, Y+16	; 0x10
 af0:	09 89       	ldd	r16, Y+17	; 0x11
		{
			PORTG = 0b00001000;
 af2:	30 83       	st	Z, r19
			PORTD = ~segment3[save1];
 af4:	a1 e0       	ldi	r26, 0x01	; 1
 af6:	b0 e0       	ldi	r27, 0x00	; 0
 af8:	ac 0f       	add	r26, r28
 afa:	bd 1f       	adc	r27, r29
 afc:	a5 0f       	add	r26, r21
 afe:	b1 1d       	adc	r27, r1
 b00:	ac 91       	ld	r26, X
 b02:	a0 95       	com	r26
 b04:	a2 bb       	out	0x12, r26	; 18
 b06:	af e1       	ldi	r26, 0x1F	; 31
 b08:	be e4       	ldi	r27, 0x4E	; 78
 b0a:	11 97       	sbiw	r26, 0x01	; 1
 b0c:	f1 f7       	brne	.-4      	; 0xb0a <__LOCK_REGION_LENGTH__+0x70a>
 b0e:	00 c0       	rjmp	.+0      	; 0xb10 <__LOCK_REGION_LENGTH__+0x710>
 b10:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 b12:	ab 85       	ldd	r26, Y+11	; 0x0b
 b14:	a0 95       	com	r26
 b16:	a2 bb       	out	0x12, r26	; 18
 b18:	af e1       	ldi	r26, 0x1F	; 31
 b1a:	be e4       	ldi	r27, 0x4E	; 78
 b1c:	11 97       	sbiw	r26, 0x01	; 1
 b1e:	f1 f7       	brne	.-4      	; 0xb1c <__LOCK_REGION_LENGTH__+0x71c>
 b20:	00 c0       	rjmp	.+0      	; 0xb22 <__LOCK_REGION_LENGTH__+0x722>
 b22:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 b24:	90 83       	st	Z, r25
			PORTD = ~segment3[save2];
 b26:	a1 e0       	ldi	r26, 0x01	; 1
 b28:	b0 e0       	ldi	r27, 0x00	; 0
 b2a:	ac 0f       	add	r26, r28
 b2c:	bd 1f       	adc	r27, r29
 b2e:	a6 0f       	add	r26, r22
 b30:	b1 1d       	adc	r27, r1
 b32:	ac 91       	ld	r26, X
 b34:	a0 95       	com	r26
 b36:	a2 bb       	out	0x12, r26	; 18
 b38:	af e1       	ldi	r26, 0x1F	; 31
 b3a:	be e4       	ldi	r27, 0x4E	; 78
 b3c:	11 97       	sbiw	r26, 0x01	; 1
 b3e:	f1 f7       	brne	.-4      	; 0xb3c <__LOCK_REGION_LENGTH__+0x73c>
 b40:	00 c0       	rjmp	.+0      	; 0xb42 <__LOCK_REGION_LENGTH__+0x742>
 b42:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 b44:	ab 85       	ldd	r26, Y+11	; 0x0b
 b46:	a0 95       	com	r26
 b48:	a2 bb       	out	0x12, r26	; 18
 b4a:	af e1       	ldi	r26, 0x1F	; 31
 b4c:	be e4       	ldi	r27, 0x4E	; 78
 b4e:	11 97       	sbiw	r26, 0x01	; 1
 b50:	f1 f7       	brne	.-4      	; 0xb4e <__LOCK_REGION_LENGTH__+0x74e>
 b52:	00 c0       	rjmp	.+0      	; 0xb54 <__LOCK_REGION_LENGTH__+0x754>
 b54:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 b56:	20 83       	st	Z, r18
			PORTD = ~segment3[save3];
 b58:	a1 e0       	ldi	r26, 0x01	; 1
 b5a:	b0 e0       	ldi	r27, 0x00	; 0
 b5c:	ac 0f       	add	r26, r28
 b5e:	bd 1f       	adc	r27, r29
 b60:	a7 0f       	add	r26, r23
 b62:	b1 1d       	adc	r27, r1
 b64:	ac 91       	ld	r26, X
 b66:	a0 95       	com	r26
 b68:	a2 bb       	out	0x12, r26	; 18
 b6a:	af e1       	ldi	r26, 0x1F	; 31
 b6c:	be e4       	ldi	r27, 0x4E	; 78
 b6e:	11 97       	sbiw	r26, 0x01	; 1
 b70:	f1 f7       	brne	.-4      	; 0xb6e <__LOCK_REGION_LENGTH__+0x76e>
 b72:	00 c0       	rjmp	.+0      	; 0xb74 <__LOCK_REGION_LENGTH__+0x774>
 b74:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 b76:	80 83       	st	Z, r24
			PORTD = ~segment3[save4];
 b78:	a1 e0       	ldi	r26, 0x01	; 1
 b7a:	b0 e0       	ldi	r27, 0x00	; 0
 b7c:	ac 0f       	add	r26, r28
 b7e:	bd 1f       	adc	r27, r29
 b80:	a0 0f       	add	r26, r16
 b82:	b1 1d       	adc	r27, r1
 b84:	ac 91       	ld	r26, X
 b86:	a0 95       	com	r26
 b88:	a2 bb       	out	0x12, r26	; 18
 b8a:	af e1       	ldi	r26, 0x1F	; 31
 b8c:	be e4       	ldi	r27, 0x4E	; 78
 b8e:	11 97       	sbiw	r26, 0x01	; 1
 b90:	f1 f7       	brne	.-4      	; 0xb8e <__LOCK_REGION_LENGTH__+0x78e>
 b92:	00 c0       	rjmp	.+0      	; 0xb94 <__LOCK_REGION_LENGTH__+0x794>
 b94:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 b96:	ab 85       	ldd	r26, Y+11	; 0x0b
 b98:	a0 95       	com	r26
 b9a:	a2 bb       	out	0x12, r26	; 18
 b9c:	af e1       	ldi	r26, 0x1F	; 31
 b9e:	be e4       	ldi	r27, 0x4E	; 78
 ba0:	11 97       	sbiw	r26, 0x01	; 1
 ba2:	f1 f7       	brne	.-4      	; 0xba0 <__LOCK_REGION_LENGTH__+0x7a0>
 ba4:	00 c0       	rjmp	.+0      	; 0xba6 <__LOCK_REGION_LENGTH__+0x7a6>
 ba6:	00 00       	nop
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
 ba8:	a1 b1       	in	r26, 0x01	; 1
 baa:	a0 7f       	andi	r26, 0xF0	; 240
 bac:	a0 37       	cpi	r26, 0x70	; 112
 bae:	c1 f4       	brne	.+48     	; 0xbe0 <__LOCK_REGION_LENGTH__+0x7e0>
 bb0:	a1 10       	cpse	r10, r1
 bb2:	16 c0       	rjmp	.+44     	; 0xbe0 <__LOCK_REGION_LENGTH__+0x7e0>
 bb4:	af e3       	ldi	r26, 0x3F	; 63
 bb6:	bc e9       	ldi	r27, 0x9C	; 156
 bb8:	11 97       	sbiw	r26, 0x01	; 1
 bba:	f1 f7       	brne	.-4      	; 0xbb8 <__LOCK_REGION_LENGTH__+0x7b8>
 bbc:	00 c0       	rjmp	.+0      	; 0xbbe <__LOCK_REGION_LENGTH__+0x7be>
 bbe:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				save3++;	//세번째 비밀번호 증가
 bc0:	7f 5f       	subi	r23, 0xFF	; 255
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
 bc2:	5a 30       	cpi	r21, 0x0A	; 10
 bc4:	09 f4       	brne	.+2      	; 0xbc8 <__LOCK_REGION_LENGTH__+0x7c8>
 bc6:	50 e0       	ldi	r21, 0x00	; 0
				if(save2 == 10) save2 = 0;
 bc8:	6a 30       	cpi	r22, 0x0A	; 10
 bca:	09 f4       	brne	.+2      	; 0xbce <__LOCK_REGION_LENGTH__+0x7ce>
 bcc:	60 e0       	ldi	r22, 0x00	; 0
				if(save3 == 10) save3 = 0;
 bce:	7a 30       	cpi	r23, 0x0A	; 10
 bd0:	09 f4       	brne	.+2      	; 0xbd4 <__LOCK_REGION_LENGTH__+0x7d4>
 bd2:	70 e0       	ldi	r23, 0x00	; 0
				if(save4 == 10) save4 = 0;
 bd4:	0a 30       	cpi	r16, 0x0A	; 10
 bd6:	19 f4       	brne	.+6      	; 0xbde <__LOCK_REGION_LENGTH__+0x7de>
 bd8:	00 e0       	ldi	r16, 0x00	; 0
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
			{
				_delay_ms(10);
				state1 = 1;
 bda:	ac 84       	ldd	r10, Y+12	; 0x0c
 bdc:	01 c0       	rjmp	.+2      	; 0xbe0 <__LOCK_REGION_LENGTH__+0x7e0>
 bde:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
				if(save2 == 10) save2 = 0;
				if(save3 == 10) save3 = 0;
				if(save4 == 10) save4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//두번째 스위치 누를 때
 be0:	a1 b1       	in	r26, 0x01	; 1
 be2:	a0 7f       	andi	r26, 0xF0	; 240
 be4:	a0 3b       	cpi	r26, 0xB0	; 176
 be6:	59 f4       	brne	.+22     	; 0xbfe <__LOCK_REGION_LENGTH__+0x7fe>
 be8:	71 10       	cpse	r7, r1
 bea:	0b c0       	rjmp	.+22     	; 0xc02 <__LOCK_REGION_LENGTH__+0x802>
 bec:	af e3       	ldi	r26, 0x3F	; 63
 bee:	bc e9       	ldi	r27, 0x9C	; 156
 bf0:	11 97       	sbiw	r26, 0x01	; 1
 bf2:	f1 f7       	brne	.-4      	; 0xbf0 <__LOCK_REGION_LENGTH__+0x7f0>
 bf4:	00 c0       	rjmp	.+0      	; 0xbf6 <__LOCK_REGION_LENGTH__+0x7f6>
 bf6:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 bf8:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 8;	//다음 비밀번호로 이동
 bfa:	b3 2f       	mov	r27, r19
 bfc:	03 c0       	rjmp	.+6      	; 0xc04 <__LOCK_REGION_LENGTH__+0x804>
 bfe:	b8 2d       	mov	r27, r8
 c00:	01 c0       	rjmp	.+2      	; 0xc04 <__LOCK_REGION_LENGTH__+0x804>
 c02:	b8 2d       	mov	r27, r8
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
 c04:	a1 b1       	in	r26, 0x01	; 1
 c06:	a0 7f       	andi	r26, 0xF0	; 240
 c08:	a0 3d       	cpi	r26, 0xD0	; 208
 c0a:	b9 f4       	brne	.+46     	; 0xc3a <__LOCK_REGION_LENGTH__+0x83a>
 c0c:	41 11       	cpse	r20, r1
 c0e:	15 c0       	rjmp	.+42     	; 0xc3a <__LOCK_REGION_LENGTH__+0x83a>
 c10:	f8 8a       	std	Y+16, r15	; 0x10
 c12:	09 8b       	std	Y+17, r16	; 0x11
 c14:	af e3       	ldi	r26, 0x3F	; 63
 c16:	bc e9       	ldi	r27, 0x9C	; 156
 c18:	11 97       	sbiw	r26, 0x01	; 1
 c1a:	f1 f7       	brne	.-4      	; 0xc18 <__LOCK_REGION_LENGTH__+0x818>
 c1c:	00 c0       	rjmp	.+0      	; 0xc1e <__LOCK_REGION_LENGTH__+0x81e>
 c1e:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 c20:	f1 b0       	in	r15, 0x01	; 1
 c22:	bf 2d       	mov	r27, r15
 c24:	b0 7f       	andi	r27, 0xF0	; 240
 c26:	a0 ef       	ldi	r26, 0xF0	; 240
 c28:	ba 17       	cp	r27, r26
 c2a:	09 f4       	brne	.+2      	; 0xc2e <__LOCK_REGION_LENGTH__+0x82e>
 c2c:	d5 c0       	rjmp	.+426    	; 0xdd8 <__LOCK_REGION_LENGTH__+0x9d8>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 c2e:	0f 2e       	mov	r0, r31
 c30:	f9 e0       	ldi	r31, 0x09	; 9
 c32:	df 2e       	mov	r13, r31
 c34:	f0 2d       	mov	r31, r0
				phase = 8;	//다음 비밀번호로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
 c36:	48 2f       	mov	r20, r24
 c38:	18 c0       	rjmp	.+48     	; 0xc6a <__LOCK_REGION_LENGTH__+0x86a>
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 c3a:	a1 b1       	in	r26, 0x01	; 1
 c3c:	a0 7f       	andi	r26, 0xF0	; 240
 c3e:	a0 3f       	cpi	r26, 0xF0	; 240
 c40:	21 f4       	brne	.+8      	; 0xc4a <__LOCK_REGION_LENGTH__+0x84a>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 c42:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 c44:	46 2d       	mov	r20, r6
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 c46:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 c48:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 7)	//비밀번호 3번째 숫자 변경
 c4a:	b7 30       	cpi	r27, 0x07	; 7
 c4c:	09 f4       	brne	.+2      	; 0xc50 <__LOCK_REGION_LENGTH__+0x850>
 c4e:	51 cf       	rjmp	.-350    	; 0xaf2 <__LOCK_REGION_LENGTH__+0x6f2>
 c50:	09 8b       	std	Y+17, r16	; 0x11
 c52:	db 2e       	mov	r13, r27
 c54:	f8 8a       	std	Y+16, r15	; 0x10
 c56:	09 c0       	rjmp	.+18     	; 0xc6a <__LOCK_REGION_LENGTH__+0x86a>
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 c58:	21 2c       	mov	r2, r1
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 c5a:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 c5c:	a1 2c       	mov	r10, r1
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 c5e:	0f 2e       	mov	r0, r31
 c60:	f9 e0       	ldi	r31, 0x09	; 9
 c62:	df 2e       	mov	r13, r31
 c64:	f0 2d       	mov	r31, r0
 c66:	01 c0       	rjmp	.+2      	; 0xc6a <__LOCK_REGION_LENGTH__+0x86a>
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 7)	//비밀번호 3번째 숫자 변경
 c68:	d8 2c       	mov	r13, r8
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 8)	//비밀번호 4번째 숫자 변경
 c6a:	b8 e0       	ldi	r27, 0x08	; 8
 c6c:	db 12       	cpse	r13, r27
 c6e:	bc c0       	rjmp	.+376    	; 0xde8 <__LOCK_REGION_LENGTH__+0x9e8>
 c70:	f8 88       	ldd	r15, Y+16	; 0x10
 c72:	09 89       	ldd	r16, Y+17	; 0x11
		{
			PORTG = 0b00001000;
 c74:	30 83       	st	Z, r19
			PORTD = ~segment3[save1];
 c76:	a1 e0       	ldi	r26, 0x01	; 1
 c78:	b0 e0       	ldi	r27, 0x00	; 0
 c7a:	ac 0f       	add	r26, r28
 c7c:	bd 1f       	adc	r27, r29
 c7e:	a5 0f       	add	r26, r21
 c80:	b1 1d       	adc	r27, r1
 c82:	ac 91       	ld	r26, X
 c84:	a0 95       	com	r26
 c86:	a2 bb       	out	0x12, r26	; 18
 c88:	af e1       	ldi	r26, 0x1F	; 31
 c8a:	be e4       	ldi	r27, 0x4E	; 78
 c8c:	11 97       	sbiw	r26, 0x01	; 1
 c8e:	f1 f7       	brne	.-4      	; 0xc8c <__LOCK_REGION_LENGTH__+0x88c>
 c90:	00 c0       	rjmp	.+0      	; 0xc92 <__LOCK_REGION_LENGTH__+0x892>
 c92:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 c94:	ab 85       	ldd	r26, Y+11	; 0x0b
 c96:	a0 95       	com	r26
 c98:	a2 bb       	out	0x12, r26	; 18
 c9a:	af e1       	ldi	r26, 0x1F	; 31
 c9c:	be e4       	ldi	r27, 0x4E	; 78
 c9e:	11 97       	sbiw	r26, 0x01	; 1
 ca0:	f1 f7       	brne	.-4      	; 0xc9e <__LOCK_REGION_LENGTH__+0x89e>
 ca2:	00 c0       	rjmp	.+0      	; 0xca4 <__LOCK_REGION_LENGTH__+0x8a4>
 ca4:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000100;
 ca6:	90 83       	st	Z, r25
			PORTD = ~segment3[save2];
 ca8:	a1 e0       	ldi	r26, 0x01	; 1
 caa:	b0 e0       	ldi	r27, 0x00	; 0
 cac:	ac 0f       	add	r26, r28
 cae:	bd 1f       	adc	r27, r29
 cb0:	a6 0f       	add	r26, r22
 cb2:	b1 1d       	adc	r27, r1
 cb4:	ac 91       	ld	r26, X
 cb6:	a0 95       	com	r26
 cb8:	a2 bb       	out	0x12, r26	; 18
 cba:	af e1       	ldi	r26, 0x1F	; 31
 cbc:	be e4       	ldi	r27, 0x4E	; 78
 cbe:	11 97       	sbiw	r26, 0x01	; 1
 cc0:	f1 f7       	brne	.-4      	; 0xcbe <__LOCK_REGION_LENGTH__+0x8be>
 cc2:	00 c0       	rjmp	.+0      	; 0xcc4 <__LOCK_REGION_LENGTH__+0x8c4>
 cc4:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 cc6:	ab 85       	ldd	r26, Y+11	; 0x0b
 cc8:	a0 95       	com	r26
 cca:	a2 bb       	out	0x12, r26	; 18
 ccc:	af e1       	ldi	r26, 0x1F	; 31
 cce:	be e4       	ldi	r27, 0x4E	; 78
 cd0:	11 97       	sbiw	r26, 0x01	; 1
 cd2:	f1 f7       	brne	.-4      	; 0xcd0 <__LOCK_REGION_LENGTH__+0x8d0>
 cd4:	00 c0       	rjmp	.+0      	; 0xcd6 <__LOCK_REGION_LENGTH__+0x8d6>
 cd6:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000010;
 cd8:	20 83       	st	Z, r18
			PORTD = ~segment3[save3];
 cda:	a1 e0       	ldi	r26, 0x01	; 1
 cdc:	b0 e0       	ldi	r27, 0x00	; 0
 cde:	ac 0f       	add	r26, r28
 ce0:	bd 1f       	adc	r27, r29
 ce2:	a7 0f       	add	r26, r23
 ce4:	b1 1d       	adc	r27, r1
 ce6:	ac 91       	ld	r26, X
 ce8:	a0 95       	com	r26
 cea:	a2 bb       	out	0x12, r26	; 18
 cec:	af e1       	ldi	r26, 0x1F	; 31
 cee:	be e4       	ldi	r27, 0x4E	; 78
 cf0:	11 97       	sbiw	r26, 0x01	; 1
 cf2:	f1 f7       	brne	.-4      	; 0xcf0 <__LOCK_REGION_LENGTH__+0x8f0>
 cf4:	00 c0       	rjmp	.+0      	; 0xcf6 <__LOCK_REGION_LENGTH__+0x8f6>
 cf6:	00 00       	nop
			_delay_ms(5);

			PORTD = ~segment3[10];
 cf8:	ab 85       	ldd	r26, Y+11	; 0x0b
 cfa:	a0 95       	com	r26
 cfc:	a2 bb       	out	0x12, r26	; 18
 cfe:	af e1       	ldi	r26, 0x1F	; 31
 d00:	be e4       	ldi	r27, 0x4E	; 78
 d02:	11 97       	sbiw	r26, 0x01	; 1
 d04:	f1 f7       	brne	.-4      	; 0xd02 <__LOCK_REGION_LENGTH__+0x902>
 d06:	00 c0       	rjmp	.+0      	; 0xd08 <__LOCK_REGION_LENGTH__+0x908>
 d08:	00 00       	nop
			_delay_ms(5);

			PORTG = 0b00000001;
 d0a:	80 83       	st	Z, r24
			PORTD = ~segment3[save4];
 d0c:	a1 e0       	ldi	r26, 0x01	; 1
 d0e:	b0 e0       	ldi	r27, 0x00	; 0
 d10:	ac 0f       	add	r26, r28
 d12:	bd 1f       	adc	r27, r29
 d14:	a0 0f       	add	r26, r16
 d16:	b1 1d       	adc	r27, r1
 d18:	ac 91       	ld	r26, X
 d1a:	a0 95       	com	r26
 d1c:	a2 bb       	out	0x12, r26	; 18
 d1e:	af e1       	ldi	r26, 0x1F	; 31
 d20:	be e4       	ldi	r27, 0x4E	; 78
 d22:	11 97       	sbiw	r26, 0x01	; 1
 d24:	f1 f7       	brne	.-4      	; 0xd22 <__LOCK_REGION_LENGTH__+0x922>
 d26:	00 c0       	rjmp	.+0      	; 0xd28 <__LOCK_REGION_LENGTH__+0x928>
 d28:	00 00       	nop
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
 d2a:	a1 b1       	in	r26, 0x01	; 1
 d2c:	a0 7f       	andi	r26, 0xF0	; 240
 d2e:	a0 37       	cpi	r26, 0x70	; 112
 d30:	c1 f4       	brne	.+48     	; 0xd62 <__LOCK_REGION_LENGTH__+0x962>
 d32:	a1 10       	cpse	r10, r1
 d34:	16 c0       	rjmp	.+44     	; 0xd62 <__LOCK_REGION_LENGTH__+0x962>
 d36:	af e3       	ldi	r26, 0x3F	; 63
 d38:	bc e9       	ldi	r27, 0x9C	; 156
 d3a:	11 97       	sbiw	r26, 0x01	; 1
 d3c:	f1 f7       	brne	.-4      	; 0xd3a <__LOCK_REGION_LENGTH__+0x93a>
 d3e:	00 c0       	rjmp	.+0      	; 0xd40 <__LOCK_REGION_LENGTH__+0x940>
 d40:	00 00       	nop
			{
				_delay_ms(10);
				state1 = 1;
				save4++;	//네번째 비밀번호 증가
 d42:	0f 5f       	subi	r16, 0xFF	; 255
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
 d44:	5a 30       	cpi	r21, 0x0A	; 10
 d46:	09 f4       	brne	.+2      	; 0xd4a <__LOCK_REGION_LENGTH__+0x94a>
 d48:	50 e0       	ldi	r21, 0x00	; 0
				if(save2 == 10) save2 = 0;
 d4a:	6a 30       	cpi	r22, 0x0A	; 10
 d4c:	09 f4       	brne	.+2      	; 0xd50 <__LOCK_REGION_LENGTH__+0x950>
 d4e:	60 e0       	ldi	r22, 0x00	; 0
				if(save3 == 10) save3 = 0;
 d50:	7a 30       	cpi	r23, 0x0A	; 10
 d52:	09 f4       	brne	.+2      	; 0xd56 <__LOCK_REGION_LENGTH__+0x956>
 d54:	70 e0       	ldi	r23, 0x00	; 0
				if(save4 == 10) save4 = 0;
 d56:	0a 30       	cpi	r16, 0x0A	; 10
 d58:	19 f4       	brne	.+6      	; 0xd60 <__LOCK_REGION_LENGTH__+0x960>
 d5a:	00 e0       	ldi	r16, 0x00	; 0
			_delay_ms(5);

			if(((PINE & 0xF0) == 0b01110000) && (state1 == 0))	//첫번째 스위치 누를 때
			{
				_delay_ms(10);
				state1 = 1;
 d5c:	ac 84       	ldd	r10, Y+12	; 0x0c
 d5e:	01 c0       	rjmp	.+2      	; 0xd62 <__LOCK_REGION_LENGTH__+0x962>
 d60:	ac 84       	ldd	r10, Y+12	; 0x0c
				if(save1 == 10) save1 = 0;	//10일때 다시 0으로
				if(save2 == 10) save2 = 0;
				if(save3 == 10) save3 = 0;
				if(save4 == 10) save4 = 0;
			}
			if(((PINE & 0xF0) == 0b10110000) && (state2 == 0))	//두번째 스위치 누를 때
 d62:	a1 b1       	in	r26, 0x01	; 1
 d64:	a0 7f       	andi	r26, 0xF0	; 240
 d66:	a0 3b       	cpi	r26, 0xB0	; 176
 d68:	59 f4       	brne	.+22     	; 0xd80 <__LOCK_REGION_LENGTH__+0x980>
 d6a:	71 10       	cpse	r7, r1
 d6c:	0b c0       	rjmp	.+22     	; 0xd84 <__LOCK_REGION_LENGTH__+0x984>
 d6e:	af e3       	ldi	r26, 0x3F	; 63
 d70:	bc e9       	ldi	r27, 0x9C	; 156
 d72:	11 97       	sbiw	r26, 0x01	; 1
 d74:	f1 f7       	brne	.-4      	; 0xd72 <__LOCK_REGION_LENGTH__+0x972>
 d76:	00 c0       	rjmp	.+0      	; 0xd78 <__LOCK_REGION_LENGTH__+0x978>
 d78:	00 00       	nop
			{
				_delay_ms(10);
				state2 = 1;
 d7a:	7c 84       	ldd	r7, Y+12	; 0x0c
				phase = 5;	//처음 비밀번호로 이동
 d7c:	b5 e0       	ldi	r27, 0x05	; 5
 d7e:	03 c0       	rjmp	.+6      	; 0xd86 <__LOCK_REGION_LENGTH__+0x986>
 d80:	bd 2d       	mov	r27, r13
 d82:	01 c0       	rjmp	.+2      	; 0xd86 <__LOCK_REGION_LENGTH__+0x986>
 d84:	bd 2d       	mov	r27, r13
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
 d86:	a1 b1       	in	r26, 0x01	; 1
 d88:	a0 7f       	andi	r26, 0xF0	; 240
 d8a:	a0 3d       	cpi	r26, 0xD0	; 208
 d8c:	b1 f4       	brne	.+44     	; 0xdba <__LOCK_REGION_LENGTH__+0x9ba>
 d8e:	41 11       	cpse	r20, r1
 d90:	14 c0       	rjmp	.+40     	; 0xdba <__LOCK_REGION_LENGTH__+0x9ba>
 d92:	f8 8a       	std	Y+16, r15	; 0x10
 d94:	09 8b       	std	Y+17, r16	; 0x11
 d96:	af e3       	ldi	r26, 0x3F	; 63
 d98:	bc e9       	ldi	r27, 0x9C	; 156
 d9a:	11 97       	sbiw	r26, 0x01	; 1
 d9c:	f1 f7       	brne	.-4      	; 0xd9a <__LOCK_REGION_LENGTH__+0x99a>
 d9e:	00 c0       	rjmp	.+0      	; 0xda0 <__LOCK_REGION_LENGTH__+0x9a0>
 da0:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 da2:	f1 b0       	in	r15, 0x01	; 1
 da4:	bf 2d       	mov	r27, r15
 da6:	b0 7f       	andi	r27, 0xF0	; 240
 da8:	a0 ef       	ldi	r26, 0xF0	; 240
 daa:	ba 17       	cp	r27, r26
 dac:	11 f1       	breq	.+68     	; 0xdf2 <__LOCK_REGION_LENGTH__+0x9f2>
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 dae:	0f 2e       	mov	r0, r31
 db0:	f9 e0       	ldi	r31, 0x09	; 9
 db2:	9f 2e       	mov	r9, r31
 db4:	f0 2d       	mov	r31, r0
				phase = 5;	//처음 비밀번호로 이동
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
 db6:	48 2f       	mov	r20, r24
 db8:	18 c0       	rjmp	.+48     	; 0xdea <__LOCK_REGION_LENGTH__+0x9ea>
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
 dba:	a1 b1       	in	r26, 0x01	; 1
 dbc:	a0 7f       	andi	r26, 0xF0	; 240
 dbe:	a0 3f       	cpi	r26, 0xF0	; 240
 dc0:	21 f4       	brne	.+8      	; 0xdca <__LOCK_REGION_LENGTH__+0x9ca>
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 dc2:	26 2c       	mov	r2, r6
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
 dc4:	46 2d       	mov	r20, r6
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 dc6:	76 2c       	mov	r7, r6
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 dc8:	a6 2c       	mov	r10, r6
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 8)	//비밀번호 4번째 숫자 변경
 dca:	b8 30       	cpi	r27, 0x08	; 8
 dcc:	09 f4       	brne	.+2      	; 0xdd0 <__LOCK_REGION_LENGTH__+0x9d0>
 dce:	52 cf       	rjmp	.-348    	; 0xc74 <__LOCK_REGION_LENGTH__+0x874>
 dd0:	9b 2e       	mov	r9, r27
 dd2:	f8 8a       	std	Y+16, r15	; 0x10
 dd4:	09 8b       	std	Y+17, r16	; 0x11
 dd6:	09 c0       	rjmp	.+18     	; 0xdea <__LOCK_REGION_LENGTH__+0x9ea>
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 dd8:	21 2c       	mov	r2, r1
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 dda:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 ddc:	a1 2c       	mov	r10, r1
			}
			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0)) //3번째 스위치 누를 때
			{
				_delay_ms(10);
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
 dde:	0f 2e       	mov	r0, r31
 de0:	f9 e0       	ldi	r31, 0x09	; 9
 de2:	9f 2e       	mov	r9, r31
 de4:	f0 2d       	mov	r31, r0
 de6:	01 c0       	rjmp	.+2      	; 0xdea <__LOCK_REGION_LENGTH__+0x9ea>
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 8)	//비밀번호 4번째 숫자 변경
 de8:	9d 2c       	mov	r9, r13
				state2 = 0;
				state3 = 0;
				state4 = 0;
			}
		}
		while(phase == 9)	//비밀번호 변경 완료 단계
 dea:	b9 e0       	ldi	r27, 0x09	; 9
 dec:	9b 16       	cp	r9, r27
 dee:	21 f0       	breq	.+8      	; 0xdf8 <__LOCK_REGION_LENGTH__+0x9f8>
 df0:	46 ca       	rjmp	.-2932   	; 0x27e <main+0x1c6>
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
				state3 = 0;
				state4 = 0;
 df2:	21 2c       	mov	r2, r1
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
				state2 = 0;
 df4:	71 2c       	mov	r7, r1
				state3 = 1;
				phase = 9;	//비밀번호 변경 완료 단계로 이동
			}
			if((PINE & 0xF0) == 0xF0)
			{
				state1 = 0;
 df6:	a1 2c       	mov	r10, r1
 df8:	f8 88       	ldd	r15, Y+16	; 0x10
 dfa:	e9 88       	ldd	r14, Y+17	; 0x11
				state4 = 0;
			}
		}
		while(phase == 9)	//비밀번호 변경 완료 단계
		{
			PORTG = 0b00001000;
 dfc:	30 83       	st	Z, r19
			PORTD = ~(0b00111001);	//네모 표시 출력
 dfe:	52 ba       	out	0x12, r5	; 18
 e00:	af e1       	ldi	r26, 0x1F	; 31
 e02:	be e4       	ldi	r27, 0x4E	; 78
 e04:	11 97       	sbiw	r26, 0x01	; 1
 e06:	f1 f7       	brne	.-4      	; 0xe04 <__LOCK_REGION_LENGTH__+0xa04>
 e08:	00 c0       	rjmp	.+0      	; 0xe0a <__LOCK_REGION_LENGTH__+0xa0a>
 e0a:	00 00       	nop
			_delay_ms(5);
			PORTG = 0b00000100;
 e0c:	90 83       	st	Z, r25
			PORTD = ~(0b00001001);
 e0e:	12 bb       	out	0x12, r17	; 18
 e10:	af e1       	ldi	r26, 0x1F	; 31
 e12:	be e4       	ldi	r27, 0x4E	; 78
 e14:	11 97       	sbiw	r26, 0x01	; 1
 e16:	f1 f7       	brne	.-4      	; 0xe14 <__LOCK_REGION_LENGTH__+0xa14>
 e18:	00 c0       	rjmp	.+0      	; 0xe1a <__LOCK_REGION_LENGTH__+0xa1a>
 e1a:	00 00       	nop
			_delay_ms(5);
			PORTG = 0b00000010;
 e1c:	20 83       	st	Z, r18
			PORTD = ~(0b00001001);
 e1e:	12 bb       	out	0x12, r17	; 18
 e20:	af e1       	ldi	r26, 0x1F	; 31
 e22:	be e4       	ldi	r27, 0x4E	; 78
 e24:	11 97       	sbiw	r26, 0x01	; 1
 e26:	f1 f7       	brne	.-4      	; 0xe24 <__LOCK_REGION_LENGTH__+0xa24>
 e28:	00 c0       	rjmp	.+0      	; 0xe2a <__LOCK_REGION_LENGTH__+0xa2a>
 e2a:	00 00       	nop
			_delay_ms(5);
			PORTG = 0b00000001;
 e2c:	80 83       	st	Z, r24
			PORTD = ~(0b00001111);
 e2e:	42 ba       	out	0x12, r4	; 18
 e30:	af e1       	ldi	r26, 0x1F	; 31
 e32:	be e4       	ldi	r27, 0x4E	; 78
 e34:	11 97       	sbiw	r26, 0x01	; 1
 e36:	f1 f7       	brne	.-4      	; 0xe34 <__LOCK_REGION_LENGTH__+0xa34>
 e38:	00 c0       	rjmp	.+0      	; 0xe3a <__LOCK_REGION_LENGTH__+0xa3a>
 e3a:	00 00       	nop
			_delay_ms(5);


			if(((PINE & 0xF0) == 0b11010000) && (state3 == 0))	//3번째 스위치 누를 때
 e3c:	01 b1       	in	r16, 0x01	; 1
 e3e:	00 7f       	andi	r16, 0xF0	; 240
 e40:	00 3d       	cpi	r16, 0xD0	; 208
 e42:	69 f4       	brne	.+26     	; 0xe5e <__LOCK_REGION_LENGTH__+0xa5e>
 e44:	41 11       	cpse	r20, r1
 e46:	0b c0       	rjmp	.+22     	; 0xe5e <__LOCK_REGION_LENGTH__+0xa5e>
 e48:	f8 8a       	std	Y+16, r15	; 0x10
 e4a:	e9 8a       	std	Y+17, r14	; 0x11
 e4c:	af e3       	ldi	r26, 0x3F	; 63
 e4e:	bc e9       	ldi	r27, 0x9C	; 156
 e50:	11 97       	sbiw	r26, 0x01	; 1
 e52:	f1 f7       	brne	.-4      	; 0xe50 <__LOCK_REGION_LENGTH__+0xa50>
 e54:	00 c0       	rjmp	.+0      	; 0xe56 <__LOCK_REGION_LENGTH__+0xa56>
 e56:	00 00       	nop
			{
				_delay_ms(10);
				state3 = 1;
 e58:	48 2f       	mov	r20, r24
				phase = 0;	// 다시 비밀번호 입력 단계로 이동
 e5a:	91 2c       	mov	r9, r1
 e5c:	10 ca       	rjmp	.-3040   	; 0x27e <main+0x1c6>
			}
			else if((PINE & 0xF0) == 0xF0)
 e5e:	01 b1       	in	r16, 0x01	; 1
 e60:	00 7f       	andi	r16, 0xF0	; 240
 e62:	00 3f       	cpi	r16, 0xF0	; 240
 e64:	59 f6       	brne	.-106    	; 0xdfc <__LOCK_REGION_LENGTH__+0x9fc>
			{
				state3 = 0;
 e66:	46 2d       	mov	r20, r6
 e68:	c9 cf       	rjmp	.-110    	; 0xdfc <__LOCK_REGION_LENGTH__+0x9fc>

00000e6a <_exit>:
 e6a:	f8 94       	cli

00000e6c <__stop_program>:
 e6c:	ff cf       	rjmp	.-2      	; 0xe6c <__stop_program>
